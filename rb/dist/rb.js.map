{"version":3,"sources":["webpack:///webpack/bootstrap f765914389b36394a2d6","webpack:///./js/errors.js","webpack:///./js/utils.js","webpack:///./js/IPlugin.js","webpack:///./js/IControl.js","webpack:///./js/screenModel.js","webpack:///./js/rbManager.js","webpack:///./css/rb.scss","webpack:///./js/animation.js","webpack:///./js/arrowsControl.js","webpack:///./js/baseDispatcher.js","webpack:///./js/controlManager.js","webpack:///./js/elementsPool.js","webpack:///./js/keydownControl.js","webpack:///./js/moving.js","webpack:///./js/screenManager.js","webpack:///./js/swipesControl.js","webpack:///./vendor/hammer.js","webpack:///./vendor/jquery.easing.js","webpack:///./js/main.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,CAAC;AAAA,qG;;;;;;ACxGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,qBAAqB,67DAA67D;AACl9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,qG;;;;;;gEC5ID;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gEC9BD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gECrCD;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,cAAc;AAChC,kBAAkB,cAAc;AAChC,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,4CAA4C;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;AAAA;;;;;;;gEC3cD;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,uBAAuB;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,qG;;;;;;AChMD,yC;;;;;;gECAA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gEC/PD;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA;;;;;;;gEC/KD;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gECzHD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gECzKD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gEC/GD;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gECpGD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,YAAY;AAC9B,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA,kBAAkB,sCAAsC;AACxD,kBAAkB,sCAAsC;AACxD,kBAAkB,sCAAsC;AACxD,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,QAAQ;AAC1B,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B;AACA,kBAAkB,QAAQ;AAC1B;AACA,kBAAkB,QAAQ;AAC1B,kBAAkB,gBAAgB;AAClC,kBAAkB,eAAe;AACjC,kBAAkB,cAAc;AAChC,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,yDAAyD;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AAAA;;;;;;;gECloBD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,wBAAwB,aAAa;AACrC,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;gEC9SD;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,mDAAmD,kCAAkC;AACrF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AAAA,qG;;;;;;ACxFD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM,OAAO,KAAK,EAAE,KAAK,EAAE,KAAK;AAC3C,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,MAAM,GAAG,KAAK,EAAE,KAAK;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,EAAE;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO,KAAK;AACvB,WAAW,OAAO,KAAK;AACvB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA,UAAU;AACV,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA,UAAU;AACV,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,4BAA4B,8BAA8B;;AAE1D;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB;;AAEhB;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA,kCAAkC,EAAE;;AAEpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gCAAgC,EAAE;;AAElC;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,2BAA2B,cAAc;AACzC,2BAA2B,gCAAgC;AAC3D,yBAAyB,gCAAgC;AACzD;AACA,yBAAyB,4BAA4B;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;AACA;AACA;AACA,4BAA4B,gCAAgC;;AAE5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,mGAAmG,GAAG;AACtG;;AAEA;AACA;AACA;AACA,KAAK;AAAA;AACL,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA,CAAC;;;;;;;ACllFD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,iBAAiB,QAAQ;AACzB,sBAAsB,4BAA4B;AAClD,yBAAyB,KAAK,WAAW;AACzC;AACA;AACA,GAAG;AACH;AACA,iBAAiB,QAAQ;AACzB,sBAAsB,4BAA4B;AAClD,yBAAyB,KAAK,WAAW;AACzC;AACA;AACA,GAAG;AACH;AACA,iBAAiB,QAAQ;AACzB,sBAAsB,8BAA8B;AACpD,yBAAyB,KAAK,WAAW;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;;;AAGA,C;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AAAA","file":"rb.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f765914389b36394a2d6","/**\n * Модуль, содержащий всякие полезные переменные и функции\n * @module Errors\n */\ndefine([], function() {\n\n    function CustomError(property) {\n        this.name = this.name || \"CustomError\";\n\n        this.property = property;\n        this.message = this.name + \": \" + property;\n\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CustomError);\n        } else {\n            this.stack = (new Error()).stack;\n        }\n    }\n\n    /**\n     * @class\n     * Класс ошибки, означающий неправильно переданный в функцию аргумент\n     * @param {string} argName - название аргумента\n     * @param {Object} arg - значение аргумента\n     * @constructor module:Errors~ArgumentError\n     */\n    function ArgumentError(argName, arg) {\n        if (typeof arg === 'function') {\n            arg = 'function() {...}';\n        } else {\n            arg = JSON.stringify(arg);\n        }\n        arg = 'wrong function argument \"' + argName + '\": ' + arg;\n        this.name = 'ArgumentError';\n        CustomError.apply(this, [arg]);\n    }\n    ArgumentError.prototype = Object.create(CustomError.prototype);\n    ArgumentError.prototype.constructor = ArgumentError;\n\n    /**\n     * @class\n     * Класс ошибки, означающий, что путь от одной модели до другой модели не был найден\n     * @param {ScreenModel} fromScreen - модель, из которой осуществлялся поиск\n     * @param {ScreenModel} toScreen - модель, в которую осуществлялся поиск\n     * @constructor module:Errors~PathNotFoundError\n     */\n    function PathNotFoundError(fromScreen, toScreen) {\n        this.name = 'PathNotFoundError';\n        var arg = 'path not found: from ' + fromScreen.toString() + ' to ' + toScreen.toString();\n        CustomError.apply(this, [arg]);\n    }\n    PathNotFoundError.prototype = Object.create(CustomError.prototype);\n    PathNotFoundError.prototype.constructor = PathNotFoundError;\n\n    /**\n     * @class\n     * Класс ошибки, означающий критическую ошибку логики\n     * @param {string} property - подробности ошибки\n     * @constructor module:Errors~FatalError\n     */\n    function FatalError(property) {\n        this.name = 'FatalError';\n        CustomError.apply(this, arguments);\n    }\n    FatalError.prototype = Object.create(CustomError.prototype);\n    FatalError.prototype.constructor = FatalError;\n\n    /**\n     * @class\n     * Класс ошибки, означающий, что функция интерфейса еще не реализована\n     * @param {string} module - название интерфейса\n     * @param {string} functionName - название функции\n     * @constructor module:Errors~NotRealizedError\n     */\n    function NotRealizedError(module, functionName) {\n        this.name = 'NotRealizedError';\n        var arg = 'Not realized ' + module + ':' + functionName;\n        CustomError.apply(this, [arg]);\n    }\n    NotRealizedError.prototype = Object.create(CustomError.prototype);\n    NotRealizedError.prototype.constructor = NotRealizedError;\n\n    return /** @alias module:Errors */ {\n        /**\n         * Класс ошибки, означающий неправильно переданный в функцию аргумент\n         * @type {module:Errors~ArgumentError}\n         */\n        ArgumentError: ArgumentError,\n        /**\n         * Класс ошибки, означающий, что путь от одной модели до другой модели не был найден\n         * @type {module:Errors~PathNotFoundError}\n         */\n        PathNotFoundError: PathNotFoundError,\n        /**\n         * Класс ошибки, означающий, что функция интерфейса еще не реализована\n         * @type {module:Errors~NotRealizedError}\n         */\n        NotRealizedError: NotRealizedError,\n        /**\n         * Класс ошибки, означающий критическую ошибку логики\n         * @type {module:Errors~FatalError}\n         */\n        FatalError: FatalError\n    };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/errors.js\n// module id = 0\n// module chunks = 0","/**\n * Модуль, содержащий всякие полезные переменные и функции\n * @module Utils\n */\ndefine(['errors'], function(Errors) {\n    \"use strict\";\n\n    /**\n     * Функция, возвращающая противоположную сторону к исходной\n     * @param {string} side - исходная сторона\n     * @returns {string} противоположная сторона\n     * @memberOf module:Utils\n     */\n    function oppositeSide(side) {\n        if (side === 'left') return 'right';\n        if (side === 'right') return 'left';\n        if (side === 'top') return 'bottom';\n        if (side === 'bottom') return 'top';\n        if (side === 'center') return 'center';\n        throw new Errors.ArgumentError('side', side);\n    }\n    /**\n     * Функция, возвращающая левую (верхнюю) сторону к исходной\n     * @param {string} side - исходная сторона\n     * @returns {string} левая (верхняя) сторона\n     * @memberOf module:Utils\n     */\n    function getStartSide(side) {\n        if (side === 'left') return 'left';\n        if (side === 'right') return 'left';\n        if (side === 'top') return 'top';\n        if (side === 'bottom') return 'top';\n        if (side === 'center') return 'center';\n        throw new Errors.ArgumentError('side', side);\n    }\n\n    /**\n     * Возвращает модуль числа index в конечной группе порядка length.\n     * @param {number} index - исходное число\n     * @param {number} length - порядок группы\n     * @returns {number} модуль числа\n     * @memberOf module:Utils\n     */\n    function cycledNumber(index, length) {\n        return (index % length + length) % length;\n    }\n    /**\n     * Делает первую букву строки заглавной\n     * @param {string} string - исходная строка\n     * @returns {string} строка с первой заглавной буквой\n     * @memberOf module:Utils\n     */\n    function capitalizeFirstLetter(string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    }\n    /**\n     * Подмешать миксин к классу\n     * @param {function} base - исходный класс\n     * @param {Object} mixin - миксин\n     * @memberOf module:Utils\n     */\n    function mixin(base, mixin) {\n        for(var key in mixin) {\n            if (mixin.hasOwnProperty(key)) {\n                base.prototype[key] = mixin[key];\n            }\n        }\n    }\n    /**\n     * Унаследовать класс от базового класса\n     * @param {function} child - класс-наследник\n     * @param {function} parent - базовый класс\n     * @memberOf module:Utils\n     */\n    function inherite(child, parent) {\n        child.prototype = Object.create(parent.prototype);\n        child.prototype.constructor = child;\n    }\n    /**\n     * Пустая функция\n     * @memberOf module:Utils\n     */\n    function nop() {}\n\n    // Mobile check\n    /**\n     * Возвращает флаг, является ли окружение мобильным устройством\n     * @returns {boolean} флаг, является ли окружение мобильным устройством\n     * @memberOf module:Utils\n     */\n    function mobileCheck() {\n        var check = false;\n        (function(a){if(/(android|ipad|playbook|silk|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);\n        return check;\n    }\n\n    if (!Array.prototype.find) {\n        Array.prototype.find = function(predicate) {\n            if (this == null) {\n                throw new TypeError('Array.prototype.find called on null or undefined');\n            }\n            if (typeof predicate !== 'function') {\n                throw new TypeError('predicate must be a function');\n            }\n            var list = Object(this);\n            var length = list.length >>> 0;\n            var thisArg = arguments[1];\n            var value;\n\n            for (var i = 0; i < length; i++) {\n                value = list[i];\n                if (predicate.call(thisArg, value, i, list)) {\n                    return value;\n                }\n            }\n            return undefined;\n        };\n    }\n\n    return /** @alias module:Utils */ {\n        /**\n         * Массив из возможных сторон\n         */\n        sides:  ['left', 'top', 'right', 'bottom'],\n        /**\n         * Массив из возможных сторон включая центральную\n         */\n        sidesWithCenter:  ['center', 'left', 'top', 'right', 'bottom'],\n        /**\n         * Является ли окружение мобильным устройством\n         */\n        isMobile: mobileCheck(),\n        nop: nop,\n        cycledNumber: cycledNumber,\n        oppositeSide: oppositeSide,\n        getStartSide: getStartSide,\n        capitalizeFirstLetter: capitalizeFirstLetter,\n        mixin: mixin,\n        inherite: inherite\n    };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/utils.js\n// module id = 1\n// module chunks = 0","define(['utils', 'errors'], function(Utils, Errors) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Интерфейс для плагина. Плагины, расширяющие функционал панели должны наследоваться от этого интерфейса.\n     * @constructor IPlugin\n     * @interface\n     */\n    function IPlugin() {\n    }\n\n    /**\n     * Применить конфигурацию.\n     * @param {Moving~config} config - конфигурация\n     * @memberOf IPlugin\n     */\n    IPlugin.prototype.configure = function(config) {\n        throw new Errors.NotRealizedError('IPlugin', 'configure');\n    };\n\n    /**\n     * Уничтожить экземпляр интерфейса.\n     * @memberOf IPlugin\n     */\n    IPlugin.prototype.destroy = function() {\n        throw new Errors.NotRealizedError('IPlugin', 'destroy');\n    };\n\n    return IPlugin;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/IPlugin.js\n// module id = 2\n// module chunks = 0","define(['utils', 'IPlugin', 'errors'], function(Utils, IPlugin, Errors) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Интерфейс управления панелью. Позволяет переключаться в соседние ячейки панели.\n     * @constructor IControl\n     * @interface\n     * @extends IPlugin\n     */\n    function IControl() {\n    }\n    Utils.inherite(IControl, IPlugin);\n\n    /**\n     * Возвращает флаг, включено ли управление панелью.\n     * @memberOf IControl\n     */\n    IControl.prototype.isEnable = function() {\n        throw new Errors.NotRealizedError('IControl', 'isEnable');\n    };\n    /**\n     * включить управление панелью.\n     * @memberOf IControl\n     */\n    IControl.prototype.enable = function() {\n        throw new Errors.NotRealizedError('IControl', 'enable');\n    };\n    /**\n     * выключить управление панелью.\n     * @memberOf IControl\n     */\n    IControl.prototype.disable = function() {\n        throw new Errors.NotRealizedError('IControl', 'disable');\n    };\n\n    return IControl;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/IControl.js\n// module id = 3\n// module chunks = 0","define(['errors'], function(Errors) {\n    \"use strict\";\n\n    /**\n     * Конфигурация модели\n     * @typedef {Object} ScreenModel~ScreenConfig\n     * @property {ScreenModel[]} [children] - Потомки модели\n     * @property {ScreenModel[]} [parents] - Предки модели\n     * @property {boolean} [isPermanent] - Является ли модель постоянно хранимой, если да, то попав на страницу не будет оттуда удаляться.\n     * @property {boolean} [isDirectedGraph] - Является ли строящийся граф моделей ориентированным.\n     * @property {string} [html] - Контент модели\n     * @property {number} [defaultChildIndex] - Индекс модели по умолчанию среди моделей-потомков\n     * @property {number} [defaultParentIndex] - Индекс модели по умолчанию среди моделей-предков\n     */\n    /**\n     * Конфигурация моделей по умолчанию\n     * @typedef {Object} ScreenModel~DefaultScreenConfig\n     * @property {boolean} [isPermanent] - Является ли модель постоянно хранимой, если да, то попав на страницу не будет оттуда удаляться.\n     * @property {boolean} [isDirectedGraph] - Является ли строящийся граф моделей ориентированным.\n     * @property {number} [defaultChildIndex] - Индекс модели по умолчанию среди моделей-потомков\n     * @property {number} [defaultParentIndex] - Индекс модели по умолчанию среди моделей-предков\n     */\n    /**\n     * @class\n     * Модель контента, отображаемая в ячейке панели.\n     * @param {String|ScreenModel~ScreenConfig} [html] - контент модели\n     * @param {ScreenModel[]} [children] - потомки модели\n     * @param {ScreenModel[]} [parents] - предки модели\n     * @constructor ScreenModel\n     */\n    function ScreenModel(html, children, parents) {\n        if (!ScreenModel._mainScreenSetted) {\n            ScreenModel._mainScreen = this;\n        }\n\n        this._children = [];\n        this._parents = [];\n\n        var isPermanent, isDirectedGraph, defaultChildIndex, defaultParentIndex;\n\n        if (typeof html === 'object') {\n            children = html.children;\n            parents = html.parents;\n            isPermanent = html.isPermanent;\n            isDirectedGraph = html.isDirectedGraph;\n            defaultChildIndex = html.defaultChildIndex;\n            defaultParentIndex = html.defaultParentIndex;\n            html = html.html;\n        } else if (typeof html !== 'string') {\n            html = '';\n        }\n\n        if (isPermanent === undefined) {\n            isPermanent = ScreenModel.isPermanent;\n        }\n        if (isDirectedGraph === undefined) {\n            isDirectedGraph = ScreenModel.isDirectedGraph;\n        }\n        if (defaultChildIndex === undefined) {\n            defaultChildIndex = ScreenModel.defaultChildIndex;\n        }\n        if (defaultParentIndex === undefined) {\n            defaultParentIndex = ScreenModel.defaultParentIndex;\n        }\n\n        this._id = 'screen_' + ScreenModel._length++;\n        this._html = html;\n        this._temporary = !isPermanent; // Todo на изменение тут менять и там где используется\n        this._isDirectedGraph = !!isDirectedGraph; // Todo на изменение тут менять и там где используется\n        this._defaultChildIndex = defaultChildIndex;\n        this._defaultParentIndex = defaultParentIndex;\n\n        this.resetChildren(children);\n        this.resetParents(parents);\n    }\n\n    /**\n     * Возвращает идентификатор модели\n     * @returns {string} идентификатор модели\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.toString = function() {\n        return this._id;\n    };\n\n    /**\n     * Возвращает контент модели\n     * @param {string} [html] - если аргумент задан, он будет установлен в качестве контента модели\n     * @returns {string} контент модели\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.html = function (html) {\n        if (typeof html === 'string') {\n            this._html = html;\n            // todo обновить все ячейки в которых лежит эта модель\n        }\n        return this._html;\n    };\n\n    /**\n     * Возвращает опцию \"временная модель\". Если модель временная, она не будет храниться на странице, если не отображается.\n     * @returns {boolean} опция \"временная модель\"\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.isTemporary = function() {\n        return this._temporary;\n    };\n    /**\n     * Возвращает опцию \"ориентированный граф\". Если true, модель является частью ориентированного графа.\n     * @returns {boolean} опция \"ориентированный граф\"\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.isDirectedGraph = function() {\n        return this._isDirectedGraph;\n    };\n    /**\n     * Возвращает индекс модели по умолчанию среди моделей-потомков\n     * @param {number} [index] - если задан индекс, он будет установлен как значение по умолчанию\n     * @returns {number} индекс модели по умолчанию среди моделей-потомков\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.defaultChildIndex = function(index) {\n        if (typeof index === 'number') {\n            this._defaultChildIndex = index;\n        }\n        return this._defaultChildIndex;\n    };\n    /**\n     * Возвращает индекс модели по умолчанию среди моделей-предков\n     * @param {number} [index] - если задан индекс, он будет установлен как значение по умолчанию\n     * @returns {number} индекс модели по умолчанию среди моделей-предков\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.defaultParentIndex = function(index) {\n        if (typeof index === 'number') {\n            this._defaultParentIndex = index;\n        }\n        return this._defaultParentIndex;\n    };\n\n    ScreenModel.prototype._addScreen = function(screen, isChild) {\n        if (isChild) {\n            if (this.getChildIndex(screen) !== -1) {\n                console.log('screenModel: \"' + screen.toString() + '\" child screen exists!');\n            } else {\n                this._children.push(screen); //todo смотреть что оба скрина одного типа isDirectGraph\n                screen._parents.push(this);\n            }\n        } else {\n            if (this.getParentIndex(screen) !== -1) {\n                console.log('screenModel: \"' + screen.toString() + '\" parent screen exists!');\n            } else {\n                this._parents.push(screen);\n                screen._children.push(this);\n            }\n        }\n        if (!this._isDirectedGraph) {\n            if (!screen._isAddingState) {\n                this._isAddingState = true;\n                screen._addScreen(this, isChild);\n                this._isAddingState = false;\n            }\n        }\n\n        return this;\n    };\n    ScreenModel.prototype._getScreenIndex = function(screen, arr) {\n        var index = -1;\n        if (typeof screen === 'number') {\n            if (isNaN(screen)) {\n                throw new Errors.ArgumentError('screen', screen);\n            }\n            index = screen;\n        } else if (typeof screen === 'string') {\n            screen = arr.find(function(curScreen, curIndex) {\n                if (curScreen.toString() === screen) {\n                    index = curIndex;\n                    return true;\n                }\n            });\n        } else if (screen instanceof ScreenModel) {\n            index = arr.indexOf(screen);\n        } else {\n            throw new Errors.ArgumentError('screen', screen);\n        }\n        return index;\n    };\n    ScreenModel.prototype._removeScreen = function(screen, isChild) {\n        var arr = isChild ? this._children : this._parents,\n            index = this._getScreenIndex(screen, arr);\n\n        if (index !== -1) {\n            var removed = arr.splice(index, 1)[0];\n        } else {\n            return;\n        }\n        if (isChild) {\n            removed.removeParent(this);\n        } else {\n            removed.removeChild(this);\n        }\n        if (!this._isDirectedGraph) {\n            removed._removeScreen(this, isChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * Сортирует набор потомков. Сортировка происходит по правилам сортировки массива.\n     * @param {function} [compareFn] - Если задана функция сравнения, она будет использована при сортировке.\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.sortChildren = function(compareFn) {\n        this._children = this._children.sort(compareFn);\n        ScreenModel._runUpdateFn(this);\n        return this;\n    };\n\n    /**\n     * Возвращает количество потомков.\n     * @returns {Number} количество потомков\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.childrenLength = function () {\n        return this._children.length;\n    };\n\n    /**\n     * Находит индекс модели среди набора потомков\n     * @param {ScreenModel|string|number} child - искомая модель, ее идентификатор или порядковый номер в наборе\n     * @returns {number} искомый индекс модели\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.getChildIndex = function(child) {\n        return this._getScreenIndex(child, this._children);\n    };\n    /**\n     * Находит модель среди набора потомков\n     * @param {ScreenModel|string|number} child - искомая модель, ее идентификатор или порядковый номер в наборе\n     * @returns {ScreenModel} искомая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.getChild = function(child) {\n        var index = this.getChildIndex(child);\n        return this._children[index];\n    };\n    /**\n     * Удаляет модель из набора потомков\n     * @param {ScreenModel|string|number} child - удаляемая модель, ее идентификатор или порядковый номер в наборе\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.removeChild = function(child) {\n        this._removeScreen(child, true);\n        ScreenModel._runUpdateFn(this);\n        return this;\n    };\n    /**\n     * Добавить набор моделей в конец к набору потомков\n     * @param {ScreenModel[]|ScreenModel} children - набор добавляемый моделей\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.pushChildren = function(children) {\n        if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n                this._addScreen(children[i], true);\n            }\n        } else if (children instanceof ScreenModel) {\n            this._addScreen(children, true);\n        } else {\n            ScreenModel._runUpdateFn(this);\n            throw new Errors.ArgumentError('children', children);\n        }\n        ScreenModel._runUpdateFn(this);\n        return this;\n    };\n    /**\n     * Переопределить набор моделей потомков, то есть удалить старые и установить новые\n     * @param {ScreenModel[]} [children] - набор добавляемый моделей\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.resetChildren = function(children) {\n        this._clearChildren().pushChildren(children || []);\n        return this;\n    };\n    ScreenModel.prototype._clearChildren = function() {\n        for (var i = this._children.length - 1; i >= 0; i--) {\n            this._removeScreen(this._children[i], true);\n        }\n        return this;\n    };\n\n    /**\n     * Сортирует набор предков. Сортировка происходит по правилам сортировки массива.\n     * @param {function} [compareFn] - Если задана функция сравнения, она будет использована при сортировке.\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.sortParents = function(compareFn) {\n        this._parents = this._parents.sort(compareFn);\n        ScreenModel._runUpdateFn(this);\n        return this;\n    };\n    /**\n     * Возвращает количество предков.\n     * @returns {Number} количество предков\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.parentsLength = function () {\n        return this._parents.length;\n    };\n\n    /**\n     * Находит индекс модели среди набора предков\n     * @param {ScreenModel|string|number} parent - искомая модель, ее идентификатор или порядковый номер в наборе\n     * @returns {number} искомый индекс модели\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.getParentIndex = function(parent) {\n        return this._getScreenIndex(parent, this._parents);\n    };\n    /**\n     * Находит модель среди набора предков\n     * @param {ScreenModel|string|number} parent - искомая модель, ее идентификатор или порядковый номер в наборе\n     * @returns {ScreenModel} искомая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.getParent = function(parent) {\n        var index = this.getParentIndex(parent);\n        return this._parents[index];\n    };\n    /**\n     * Удаляет модель из набора предков\n     * @param {ScreenModel|string|number} parent - удаляемая модель, ее идентификатор или порядковый номер в наборе\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.removeParent = function(parent) {\n        this._removeScreen(parent, false);\n        ScreenModel._runUpdateFn(this);\n        return this;\n    };\n    /**\n     * Добавить набор моделей в конец к набору предков\n     * @param {ScreenModel[]|ScreenModel} parents - набор добавляемый моделей\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.pushParents = function(parents) {\n        if (Array.isArray(parents)) {\n            for (var i = 0; i < parents.length; i++) {\n                this._addScreen(parents[i], false);\n            }\n        } else if (parents instanceof ScreenModel) {\n            this._addScreen(parents, false);\n        } else {\n            ScreenModel._runUpdateFn(this);\n            throw new Errors.ArgumentError('parents', parents);\n        }\n\n        ScreenModel._runUpdateFn(this);\n        return this;\n    };\n    /**\n     * Переопределить набор моделей предков, то есть удалить старые и установить новые\n     * @param {ScreenModel[]} [parents] - набор добавляемый моделей\n     * @returns {ScreenModel} текущая модель\n     * @memberOf ScreenModel\n     */\n    ScreenModel.prototype.resetParents = function(parents) {\n        this._clearParents().pushParents(parents || []);\n        return this;\n    };\n    ScreenModel.prototype._clearParents = function() {\n        for (var i = this._parents.length - 1; i >= 0; i--) {\n            this._removeScreen(this._parents[i], false);\n        }\n        return this;\n    };\n\n    /**\n     * Устанавливает конфигурацию моделей по умолчанию. Изначальные значения по умоланию: <br>\n     * isPermanent: false, <br>\n     * isDirectedGraph: true, <br>\n     * defaultChildIndex: 0, <br>\n     * defaultParentIndex: 0\n     * @param {ScreenModel~DefaultScreenConfig} config - конфигурация\n     * @memberOf ScreenModel\n     */\n    ScreenModel.configure = function(config) {\n        ScreenModel.isPermanent = config.isPermanent;\n        ScreenModel.isDirectedGraph = config.isDirectedGraph;\n        ScreenModel.defaultChildIndex = config.defaultChildIndex;\n        ScreenModel.defaultParentIndex = config.defaultParentIndex;\n    };\n    ScreenModel.configure({\n        isPermanent: false,\n        isDirectedGraph: true,\n        defaultChildIndex: 0,\n        defaultParentIndex: 0\n    });\n    ScreenModel._length = 1;\n    ScreenModel._relativeUpdateFn = [];\n\n    /**\n     * Установить модель по умолчанию, она будет использоваться в качестве стартовой для панелей, если при старте не заданы иные модели.\n     * Если модель по умолчанию не установлена вручную, будет использован первый созданный экземпляр модели.\n     * @param {ScreenModel} screen - модель по умолчанию\n     * @memberOf ScreenModel\n     * @see {@link module:RbManager.init}\n     */\n    ScreenModel.setMainScreen = function(screen) {\n        ScreenModel._mainScreen = screen;\n        ScreenModel._mainScreenSetted = true;\n    };\n    /**\n     * Получить модель по умолчанию\n     * @returns {ScreenModel} модель по умолчанию\n     * @memberOf ScreenModel\n     */\n    ScreenModel.getMainScreen = function() {\n        return ScreenModel._mainScreen;\n    };\n    /**\n     * Зарегистрировать функцию для запуска, когда изменится структура графа\n     * @param {function} fn - функция для запуска\n     * @memberOf ScreenModel\n     */\n    ScreenModel.registerUpdateFn = function(fn) {\n        ScreenModel._relativeUpdateFn.push(fn);\n    };\n    /**\n     * Удалить функцию из списка функций для запуска, когда изменится структура графа\n     * @param {function} fn - функция для запуска\n     * @memberOf ScreenModel\n     */\n    ScreenModel.unregisterUpdateFn = function(fn) {\n        ScreenModel._relativeUpdateFn = ScreenModel._relativeUpdateFn.filter(function(value) {\n            return value !== fn;\n        });\n    };\n    /**\n     * Очистить набор функций для запуска, когда изменится структура графа\n     * @memberOf ScreenModel\n     */\n    ScreenModel.clearUpdateFn = function() {\n        ScreenModel._relativeUpdateFn = [];\n    };\n    ScreenModel._runUpdateFn = function(screen) {\n        ScreenModel._relativeUpdateFn.forEach(function(fn) {\n            fn.call(undefined, screen);\n        });\n    };\n\n    return ScreenModel;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/screenModel.js\n// module id = 4\n// module chunks = 0","define(['moving'], function(Moving) {\n    \"use strict\";\n\n    /**\n     * callback-функция, которая будет выполнена после инициализации панелей\n     *\n     * @callback module:RbManager~initCallback\n     * @param {Moving[]} Instances Набор панелей, действующих в данный момент на странице\n     */\n    /**\n     * Функция, инициализирующая расположенные в данный момент на странице панели.\n     * Если startScreens не задан, первым аргументом может быть callback.\n     * Оживляются элементы с классом rb-wrapper, находящиеся на странице, в качестве идентификатора берется значение\n     * атрибута data-id или id, иначе идентификатор будет назначен самостоятельно.\n     * Инициализация запускается асинхронно, сразу как только страница будет отрендерена.\n     * @param {Object.<string, ScreenModel>} [startScreens] набор моделей контента, которые будут для панелей моделями по умолчанию.\n     * @param {module:RbManager~initCallback} [callback] функция, которая будет выполнена после инициализации панелей\n     * @memberOf module:RbManager\n     */\n    function init(startScreens, callback) {\n        if (typeof startScreens === 'function') {\n            callback = startScreens;\n            startScreens = undefined;\n        }\n\n        function waitJQuery() {\n            $(function() {\n                var $rbWrapper = $('.rb-wrapper');\n                var loadingPromises = [];\n\n                for (var i = 0; i < $rbWrapper.length; i++) {\n                    var elemWrapper = $rbWrapper.eq(i),\n                        id = elemWrapper.data('id') || elemWrapper.attr('id') || 'instance_' + i;\n\n                    if (rb.Instances[id] === undefined) {\n                        elemWrapper.html('<div class=\"rb\"><div tabindex=\"-1\" class=\"rb__fake-element\"></div></div>');\n\n                        var $rb = elemWrapper.find('>.rb'),\n                            inst = new Moving($rb, startScreens && startScreens[id]);\n                        loadingPromises.push(inst._loadingPromise);\n\n                        Object.defineProperty(rb.Instances, id, {\n                            value: inst,\n                            configurable: true,\n                            enumerable: true\n                        });\n                    }\n                }\n\n                Promise.all(loadingPromises).then(function() {\n                    callback && callback(rb.Instances);\n                });\n            });\n        }\n\n        function timeoutFunc() {\n            if (typeof jQuery === 'undefined') {\n                setTimeout(timeoutFunc, 0);\n            } else {\n                waitJQuery();\n            }\n        }\n\n        timeoutFunc();\n    }\n\n    /**\n     * Функция, удаляющая панель со страницы\n     * @param {string} id Идентификатор модели контента\n     * @memberOf module:RbManager\n     * @see {@link ScreenModel#toString}\n     */\n    function remove(id) {\n        if (rb.Instances.hasOwnProperty(id)) {\n            rb.Instances[id].destroy();\n            delete rb.Instances[id];\n        }\n    }\n\n    function batchAction(action, args) {\n        var res = [];\n        for (var id in rb.Instances) {\n            if (rb.Instances.hasOwnProperty(id)) {\n                var inst = rb.Instances[id];\n                res.push(inst[action].apply(inst, args));\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Применить конфигурацию к панелям\n     * @param {Moving~config} config - конфигурация\n     * @memberOf module:Batch\n     * @see {@link Moving#configure}\n     */\n    function configure(config) {\n        batchAction('configure', arguments);\n    }\n    /**\n     * Осуществить переход для всех панелей в указанную сторону.\n     * @param {string} side - сторона, в которую осуществляется переход\n     * @param {Boolean} [isSaveHistory] - сохранять ли осуществляемый переход в историю переходов\n     * @returns {Promise} promise о завершении действия во всех панелях\n     * @memberOf module:Batch\n     * @see {@link Moving#move}\n     */\n    function move(side, isSaveHistory) {\n        return Promise.all(batchAction('move', arguments));\n    }\n    /**\n     * Осуществить откат последнего удачного хода, воспользовавшись историей переходов.\n     * @returns {Promise} promise о завершении действия во всех панелях\n     * @memberOf module:Batch\n     * @see {@link Moving#moveBack}\n     */\n    function moveBack() {\n        return batchAction('moveBack', arguments);\n    }\n    /**\n     * Анимировать запрещенное перемещение в одну из сторон. В панели в эту сторону перемещение может быть запрещено,\n     * но будет анимировано, будто запрещено. Это полезно, например, если необходимо, чтобы либо все панели были перемещены\n     * в одну из сторон, либо все анимировали запрещенный переход.\n     * @param {string} side - сторона, в которую осуществляется переход\n     * @returns {Promise} promise о завершении действия во всех панелях\n     * @memberOf module:Batch\n     * @see {@link Moving#animateWrongSide}\n     */\n    function animateWrongSide(side) {\n        return Promise.all(batchAction('animateWrongSide', arguments));\n    }\n\n    /**\n     * Установить модель контента в текущую ячейку панелей.\n     * @param {ScreenModel} screen - Устанавливаемая модель контента\n     * @param {Boolean} [isSaveHistory] - Сохранять ли устанавливаемую модель в историю переходов\n     * @returns {Promise} promise о завершении установки модели во все панели\n     * @memberOf module:Batch\n     * @see {@link Moving#setScreen}\n     */\n    function setScreen(screen, isSaveHistory) {\n        return Promise.all(batchAction('setScreen', arguments));\n    }\n    /**\n     * Перезагрузить все панели на странице. Перезагрузка предполагает обновление верстки ячейки панели,\n     * сброс состояния в верстке. Если в элементах верстки есть подписки, необходимо позаботиться об отписке и\n     * последующей подписке к новым элементам верстки.\n     * @prop {string} side - сторона, с которой будет перезагружаться ячейка панели относительно текущей ячейки.\n     * @memberOf module:Batch\n     * @see {@link Moving#reload}\n     */\n    function reload(side) {\n        batchAction('reload', arguments);\n    }\n    /**\n     * Удалить все панели со страницы.\n     * @memberOf module:Batch\n     * @see {@link module:RbManager.remove}\n     */\n    function removeAll() {\n        for (var id in rb.Instances) {\n            remove(id);\n        }\n    }\n\n    /**\n     * Пакетированные действия на панелях, то есть выполняемые для всех панелей разом.\n     * @typedef {Object} Batch\n     * @module Batch\n     */\n    var Batch = {\n        configure: configure,\n        move: move,\n        moveBack: moveBack,\n        animateWrongSide: animateWrongSide,\n        setScreen: setScreen,\n        reload: reload,\n        removeAll: removeAll\n    };\n\n    /**\n     * Module rbManager.\n     * @module RbManager\n     */\n    return {\n        init: init,\n        remove: remove,\n        /**\n         * @type module:Batch\n         */\n        Batch: Batch\n    };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/rbManager.js\n// module id = 5\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./css/rb.scss\n// module id = 6\n// module chunks = 0","define(['utils', 'IPlugin', 'errors', 'jquery.easing'], function(Utils, IPlugin, Errors) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Класс анимации переходов в панели\n     * @param {JQuery} mainDiv - элемент, в котором располагается панель. Должен содержать класс rb-wrapper.\n     * @param {ElementsPool} elementsPool - хранилище элементов ячеек панели\n     * @constructor Animation\n     * @extends IPlugin\n     */\n    function Animation(mainDiv, elementsPool) {\n        this._elementsPool = elementsPool;\n\n        if (mainDiv instanceof $) {\n            this._mainDiv = mainDiv;\n        } else {\n            throw new Errors.ArgumentError('mainDiv', mainDiv);\n        }\n    }\n    Utils.inherite(Animation, IPlugin);\n    /**\n     * Применить конфигурацию. Учитывает опции wrongTime1, wrongTime2, correctTime, wrongEasing1, wrongEasing2, correctEasing, showAdjacentScreens.\n     * @param {Moving~config} config - конфигурация\n     * @memberOf Animation\n     */\n    Animation.prototype.configure = function(config) {\n        function fixTime(argName, time) {\n            if (typeof time === 'number') {\n                return time > 0 ? time : 1;\n            } else {\n                if (time === undefined) {\n                    return 500;\n                } else {\n                    throw new Errors.ArgumentError(argName, time);\n                }\n            }\n        }\n\n        if (typeof config === 'object') {\n            if (config.wrongTime1 !== undefined) {\n                this._wrongTime1 = fixTime('wrongTime1', config.wrongTime1);\n            }\n            if (config.wrongTime2 !== undefined) {\n                this._wrongTime2 = fixTime('wrongTime2', config.wrongTime2);\n            }\n            if (config.correctTime !== undefined) {\n                this._correctTime = fixTime('correctTime', config.correctTime);\n            }\n            if (config.wrongEasing1 !== undefined) {\n                this._wrongEasing1 = config.wrongEasing1;\n            }\n            if (config.wrongEasing2 !== undefined) {\n                this._wrongEasing2 = config.wrongEasing2;\n            }\n            if (config.correctEasing !== undefined) {\n                this._correctEasing = config.correctEasing;\n            }\n            if (config.showAdjacentScreens !== undefined) {\n                this._showAdjacentScreens = config.showAdjacentScreens;\n            }\n        }\n    };\n\n    Animation.prototype._animate = function(elem, side, value, easing, time, beforeFn, afterFn) {\n\n        beforeFn && beforeFn();\n\n        var css = {}, opts;\n        css[Utils.getStartSide(side)] = value + '%';\n        opts = {\n            duration: time,\n            easing: easing,\n            queue: false,\n            done: afterFn\n        };\n\n        elem.animate(css, opts);\n    };\n\n    Animation.prototype._updateState = function(res, elements) {\n        if (this._isAnimate) {\n            this._isAnimate = false;\n            this._new && this._new.stop();\n            this._old && this._old.stop(false, true);\n            this._cur && this._cur.stop();\n            this._prev && this._prev.stop(false, true);\n            this._next && this._next.stop(false, true);\n            this._res(false);\n        }\n        this._isAnimate = true;\n        this._old = elements.oldElem;\n        this._new = elements.newElem;\n        this._cur = elements.curElem;\n        this._prev = elements.prevElem;\n        this._next = elements.nextElem;\n        this._res = res;\n    };\n\n    /**\n     * Анимация неудачного перехода\n     * @param {string} side - сторона перехода\n     * @memberOf Animation\n     */\n    Animation.prototype.goToWrongSide = function(side) {\n        var self = this,\n            width = 100,\n            height = 100,\n            elem = this._elementsPool.getElementBySide('center'),\n            nextElem = this._elementsPool.getElementBySide(side),\n            prevElem = this._elementsPool.getElementBySide(Utils.oppositeSide(side));\n\n        return new Promise(function(res, rej) {\n            function wrongAnimate(elem, startLeft, startTop, beforeFn, afterFn) {\n                self._animate(elem, side, '+=' + value, self._wrongEasing1, self._isAnimate ? self._wrongTime1 : 10, function() {\n                    startLeft -= 100;\n                    startTop -= 100;\n                    elem.css({'left': startLeft + '%', 'top': startTop + '%'});\n                    beforeFn && beforeFn();\n                }, function() {\n                    self._animate(elem, side, '-=' + value, self._wrongEasing2, self._isAnimate ? self._wrongTime2 : 10, undefined, function() {\n                        afterFn && afterFn();\n                    });\n                });\n            }\n\n            self._updateState(res, {\n                curElem: elem,\n                prevElem: prevElem,\n                nextElem: nextElem\n            });\n\n            var dw = width/10, dh = height/10, value = 0, relValWidth = 0, relValHeight = 0;\n\n            if (side === 'left') {\n                relValWidth = -width;\n                value = - dw;\n            }\n            else if (side === 'right') {\n                relValWidth = width;\n                value = dw;\n            }\n            else if (side === 'top') {\n                relValHeight = -height;\n                value = - dh;\n            }\n            else if (side === 'bottom') {\n                relValHeight = height;\n                value = dh;\n            }\n\n            if (self._showAdjacentScreens) {\n                wrongAnimate(nextElem, width + relValWidth, height + relValHeight, function() {\n                    nextElem.toggleClass('rb__hiding-screen', true);\n                }, function() {\n                    nextElem.toggleClass('rb__hiding-screen', false);\n                }, true);\n                wrongAnimate(prevElem, width - relValWidth, height - relValHeight, function() {\n                    prevElem.toggleClass('rb__hiding-screen', true);\n                }, function() {\n                    prevElem.toggleClass('rb__hiding-screen', false);\n                }, true);\n            }\n            wrongAnimate(elem, width, height, undefined, function() {\n                self._isAnimate = false;\n                self._res(true);\n            });\n        });\n    };\n\n    /**\n     * Анимация удачного перехода\n     * @param {string} side - сторона перехода\n     * @memberOf Animation\n     */\n    Animation.prototype.goToCorrectSide = function(side) {\n        var self = this,\n            newElem = this._elementsPool.getElementBySide('center'),\n            oldElem = this._elementsPool.getElementBySide(Utils.oppositeSide(side)),\n            width = 100,\n            height = 100;\n\n        return new Promise(function(res, rej) {\n            function correctAnimate(elem, startLeft, startTop, beforeFn, afterFn) {\n                self._animate(elem, side, '-=' + value, self._correctEasing, self._correctTime, function() {\n                    startLeft -= 100;\n                    startTop -= 100;\n                    elem.css({'left': startLeft + '%', 'top': startTop + '%'});\n                    beforeFn && beforeFn();\n                }, function() {\n                    afterFn && afterFn();\n                });\n            }\n\n            self._updateState(res, {\n                oldElem: oldElem,\n                newElem: newElem\n            });\n\n            var value = 0, relValWidth = 0, relValHeight = 0;\n\n            if (side === 'left') {\n                relValWidth = -width;\n                value = - width;\n            }\n            else if (side === 'right') {\n                relValWidth = width;\n                value = width;\n            }\n            else if (side === 'top') {\n                relValHeight = -height;\n                value = - height;\n            }\n            else if (side === 'bottom') {\n                relValHeight = height;\n                value = height;\n            }\n\n            if (self._showAdjacentScreens) {\n                correctAnimate(oldElem, width, height, function () {\n                    oldElem.toggleClass('rb__hiding-screen', true);\n                }, function () {\n                    oldElem.toggleClass('rb__hiding-screen', false);\n                }, true);\n            }\n            correctAnimate(newElem, width + relValWidth, height + relValHeight, undefined, function() {\n                self._isAnimate = false;\n                self._res(true);\n            });\n        });\n    };\n\n    /**\n     * Переход в центральную ячейку\n     * @memberOf Animation\n     */\n    Animation.prototype.goToCenter = function() {\n        var elem = this._elementsPool.getElementBySide('center');\n        elem.css({'left': '0%', 'top': '0%'});\n    };\n\n    /**\n     * Уничтожить экземпляр класса анимации\n     * @memberOf Animation\n     */\n    Animation.prototype.destroy = function() {\n        this._new && this._new.stop();\n        this._old && this._old.stop();\n        this._cur && this._cur.stop();\n        this._prev && this._prev.stop();\n        this._next && this._next.stop();\n        this._res && this._res(false);\n    };\n\n    return Animation;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/animation.js\n// module id = 7\n// module chunks = 0","define(['utils', 'IControl', 'errors'], function(Utils, IControl, Errors) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Класс управления панелью с помощью стрелок, отображаемых по сторонам панели.\n     * @param {JQuery} mainDiv - элемент, в котором располагается панель. Должен содержать класс rb-wrapper.\n     * @param {function} actionFn - функция, определяющая действие при переходе в одну из сторон (Moving.prototype._moveByActionValue)\n     * @param {Moving#afterRenderDispatcher} afterRender - Диспетчер, выполняющий зарегистрированные функции после рендеринга контента моделей на странице после перехода\n     * @constructor ArrowsControl\n     * @extends IControl\n     */\n    function ArrowsControl(mainDiv, actionFn, afterRender) {\n        if (!(mainDiv instanceof $)) {\n            throw new Errors.ArgumentError('mainDiv', mainDiv);\n        }\n\n        if (typeof actionFn !== 'function') {\n            throw new Errors.ArgumentError('actionFn', actionFn);\n        }\n        this._isEnable = false;\n        this._mainDiv = mainDiv.parent();\n        this._actionFn = actionFn;\n        this._afterRender = afterRender;\n    }\n    Utils.inherite(ArrowsControl, IControl);\n\n    /**\n     * Применить конфигурацию. Учитывает опции hideArrowsTime, showArrowsOutside, showArrowsOnHover, hideArrowsAfterTime.\n     * @param {Moving~config} config\n     * @memberOf ArrowsControl\n     */\n    ArrowsControl.prototype.configure = function(config) {\n        if (typeof config === 'object') {\n            if (config.hideArrowsTime !== undefined) {\n                this._hideArrowsTime = config.hideArrowsTime;\n            }\n            if (config.showArrowsOutside !== undefined) {\n                this._showArrowsOutside = config.showArrowsOutside;\n            }\n            if (config.showArrowsOnHover !== undefined) {\n                this._showArrowsOnHover = config.showArrowsOnHover;\n            }\n            if (config.hideArrowsAfterTime !== undefined) {\n                this._hideArrowsAfterTime = config.hideArrowsAfterTime;\n            }\n        }\n        this._containerClass = (this._showArrowsOnHover ? 'rb__arrow-container-hover' : 'rb__arrow-container');\n    };\n    /**\n     *\n     * @returns {boolean}\n     * @memberOf ArrowsControl\n     */\n    ArrowsControl.prototype.isEnable = function() {\n        return this._isEnable;\n    };\n    /**\n     *\n     * @memberOf ArrowsControl\n     */\n    ArrowsControl.prototype.enable = function() {\n        if (this._isEnable) return;\n\n        var self = this;\n        var mouseEnterHandler = function(e) {\n            if (!self._hideArrowsAfterTime) return;\n\n            var arrow = $(e.currentTarget),\n                $body = $('body'),\n                arrowOffset = arrow.offset(),\n                arrowX = arrowOffset.left,\n                arrowY = arrowOffset.top,\n                arrowXX = arrowX + arrow.width(),\n                arrowYY = arrowY + arrow.height();\n\n            //var timeoutId;\n            function mouseMoveHandler(e) {\n                var x = e.clientX, y = e.clientY;\n\n                if (!(arrowX < x && x < arrowXX && arrowY < y && y < arrowYY)) {\n                    arrow.toggleClass('rb__arrow-none', false);\n                    arrow.toggleClass('rb__arrow-cursor', true);\n                    $body.off('mousemove', mouseMoveHandler);\n                    //clearTimeout(timeoutId);\n                }\n            }\n            function hideArrow() {\n                arrow.toggleClass('rb__arrow-none', true);\n                arrow.toggleClass('rb__arrow-cursor', false);\n\n                $body.on('mousemove', mouseMoveHandler);\n                //timeoutId = setTimeout(function() {\n                //    arrow.toggleClass('rb__arrow-none', false);\n                //    arrow.toggleClass('rb__arrow-cursor', true);\n                //    $body.off('mousemove', mouseMoveHandler);\n                //}, 10000);\n                // todo если из iframe не всплывает mousemove с нормальными координатами, для iframe не будет работать\n            }\n\n            if (arrow.length) {\n                arrow[0].hideArrowId = setTimeout(hideArrow, self._hideArrowsTime);\n            }\n        };\n        var mouseLeaveHandler = function(e) {\n            if (!self._hideArrowsAfterTime) return;\n\n            var arrow = $(e.currentTarget);\n            clearTimeout(arrow[0].hideArrowId);\n        };\n        var clickHandler = function(e) {\n            var arrow = $(e.currentTarget);\n\n            mouseLeaveHandler(e);\n            self._afterRender.add(mouseEnterHandler.bind(undefined, e), true);\n\n            self._actionFn(arrow, Utils.sides, function(container, defValue) {\n                return container.is('.rb__arrow-container_' + defValue);\n            });\n        };\n\n        var markup = '';\n        Utils.sides.forEach(function(side) {\n            markup += '<div class=\"' +\n                self._containerClass +\n                ' rb__arrow-cursor rb__arrow-container_' + side + '' +\n                (self._showArrowsOutside ? (' rb__arrow-outside_' + side) : '') +\n                '\">' +\n                '<div class=\"rb__arrow rb__arrow_' + side + '\"></div>' +\n                '</div>';\n        });\n        this._mainDiv.append($(markup));\n\n        var $rbArrowContainer = this._mainDiv.find('>.' + this._containerClass);\n\n        $rbArrowContainer.on('click', clickHandler);\n        $rbArrowContainer.on('mouseenter', mouseEnterHandler);\n        $rbArrowContainer.on('mouseleave', mouseLeaveHandler);\n        this._clickHandler = clickHandler;\n        this._mouseEnterHandler = mouseEnterHandler;\n        this._mouseLeaveHandler = mouseLeaveHandler;\n\n        this._isEnable = true;\n    };\n    /**\n     *\n     * @memberOf ArrowsControl\n     */\n    ArrowsControl.prototype.disable = function() {\n        if (!this._isEnable) return;\n\n        var $rbArrowContainer = this._mainDiv.find('>.' + this._containerClass);\n        for (var i = 0; i < $rbArrowContainer.length; i++) {\n            clearTimeout($rbArrowContainer[i].hideArrowId);\n        }\n        $rbArrowContainer.off('click', this._clickHandler);\n        $rbArrowContainer.off('mouseenter', this._mouseEnterHandler);\n        $rbArrowContainer.off('mouseleave', this._mouseLeaveHandler);\n        this._clickHandler = null;\n        this._mouseEnterHandler = null;\n        this._mouseLeaveHandler = null;\n\n        this._mainDiv.find('>.' + this._containerClass).remove();\n\n        this._isEnable = false;\n    };\n    /**\n     *\n     * @memberOf ArrowsControl\n     */\n    ArrowsControl.prototype.destroy = function() {\n        this.disable();\n    };\n\n    return ArrowsControl;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/arrowsControl.js\n// module id = 8\n// module chunks = 0","define(['utils', 'IPlugin'], function(Utils, IPlugin) {\n    \"use strict\";\n\n    //todo может например перейти на https://github.com/component/emitter\n    /**\n     * @class\n     * Класс диспетчера, инкапсулирует событийную модель, каждый экземпляр представляет собой событие.\n     * @param {JQuery} mainDiv - элемент, в котором располагается панель. Должен содержать класс rb-wrapper.\n     * @constructor BaseDispatcher\n     * @extends IPlugin\n     */\n    function BaseDispatcher(mainDiv) {\n        this._actions = {};\n        this._index = 0;\n        this._mainDiv = mainDiv;\n    }\n    Utils.inherite(BaseDispatcher, IPlugin);\n    BaseDispatcher.prototype.configure = function(config) {\n        if (typeof config === 'object') {\n            if (config.loadingDiv !== undefined) {\n                this._loadingDiv = $(config.loadingDiv);\n            }\n        }\n    };\n\n    // todo сделать не once, а дать возможность указать число - количество срабатываний,\n    // или функцию которая если вернет true - не отписываться, false - отписываться\n    /**\n     * Зарегистрировать действие, которое выполнится при запуске действий\n     * @param {function} action - регистрируемое действие\n     * @param {boolean} [once] - выполнить действие только в первый раз\n     * @returns {number|null} индекс зарегистрированного действия (null, если действие не было зарегистрировано)\n     * @memberOf BaseDispatcher\n     */\n    BaseDispatcher.prototype.add = function(action, once) {\n        if (typeof action === 'function') {\n            this._actions[this._index++] = {\n                action: action,\n                once: once\n            };\n            return this._index-1;\n        }\n        return null;\n    };\n    // todo отписка не по индексу, а по функции\n    /**\n     * Удалить действие из списка зарегистрированных действий\n     * @param {number} index - индекс удаляемого действия\n     * @memberOf BaseDispatcher\n     */\n    BaseDispatcher.prototype.remove = function(index) {\n        if (this._actions.hasOwnProperty(index)) {\n            delete this._actions[index];\n        }\n    };\n    /**\n     * Запустить зарегистрированные действия\n     * @param {function} [fn] - функция, которая будет выполнена после того, как выполнятся все зарегистрированные действия.\n     * Если зарегистрированные функции возвращают Promise, функция выполнится после завершения этих Promise.\n     * Если хотя бы одна из зарегистрированных функций (или их Promise) вернет false, фунция fn не будет вызвана.\n     * @param {Array} [actionArgs] - аргументы для зарегистрированных функций (для всех функций будут переданы одни и те же аргументы).\n     * @returns {*} Результат выполнения функции fn, либо undefined если функция fn не была вызвана\n     * @memberOf BaseDispatcher\n     */\n    BaseDispatcher.prototype.runActions = function(fn, actionArgs) {\n        var\n            actions = [],\n            results = [],\n            self = this;\n\n        if (Object.keys(this._actions).length) {\n            this._mainDiv.append(this._loadingDiv); // todo вынести это в moving, а здесь просто вызывать функцию\n\n            Object.keys(this._actions).map(function(index) {\n                var value = this._actions[index],\n                    result = value.action.apply(undefined, actionArgs);\n\n                if (value.once) {\n                    delete this._actions[index];\n                }\n                if (result instanceof Promise) {\n                    actions.push(result);\n                } else {\n                    results.push(result);\n                }\n            }.bind(this));\n\n            return Promise.all(actions).then(function(promiseResult) {\n                self._loadingDiv.remove();\n\n                var isOk = results.concat(promiseResult).every(function(res) {\n                    return res !== false;\n                });\n                if (isOk) {\n                    return fn && fn();\n                }\n            }, function(error) {\n                self._loadingDiv.remove();\n                console.error(error);\n\n                var isOk = results.every(function(res) {\n                    return res !== false;\n                });\n                if (isOk) {\n                    return fn && fn();\n                }\n            });\n        } else {\n            return fn && fn();\n        }\n    };\n\n    /**\n     * Уничтожить экземпляр класса\n     * @memberOf BaseDispatcher\n     */\n    BaseDispatcher.prototype.destroy = function() {\n        this._actions = null;\n    };\n\n    return BaseDispatcher;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/baseDispatcher.js\n// module id = 9\n// module chunks = 0","define([], function() {\n    \"use strict\";\n    // todo может быть можно унаследовать от IPlugin?\n    // todo а почему это класс, а не модуль?\n\n    /**\n     * @class\n     * Менеджер управлений панелью.\n     * @constructor ControlManager\n     */\n    function ControlManager() {\n        this._controls = {};\n    }\n\n    /**\n     * Добавляет экземпляр управления панелью к общему набору экземпляров, которыми можно управлять панелью.\n     * @param {string} id - название экземпляра управления панелью\n     * @param {IControl} control - добавляемый экземпляр управления панелью\n     * @param {boolean} [doEnable] - включать управление панелью при добавлении\n     * @returns {ControlManager} менеджер управления панелью\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.add = function(id, control, doEnable) {\n        if (this._controls.hasOwnProperty(id)) {\n            console.log('ControlManager - add - control already exists: ' + id);\n        } else {\n            this._controls[id] = control;\n            if (doEnable) {\n                this.enable(id);\n            }\n        }\n\n        return this;\n    };\n    /**\n     * Удаляет экземпляр управления панелью из общего набора экземпляров\n     * @param {string} id - название экземпляра управления панелью\n     * @returns {ControlManager} менеджер управления панелью\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.remove = function(id) {\n        if (this._controls.hasOwnProperty(id)) {\n            delete this._controls[id];\n        } else {\n            console.log('ControlManager - remove - control not found: ' + id);\n        }\n        return this;\n    };\n    /**\n     * Возвращает флаг, является ли экземпляр управления включенным.\n     * @param {string} id - название экземпляра\n     * @returns {boolean|null} - true если включен, false если выключен, null если не найден\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.isEnable = function(id) {\n        if (this._controls.hasOwnProperty(id)) {\n            return this._controls[id].isEnable();\n        } else {\n            //todo выводить как-то иначе\n            console.log('ControlManager - isEnable - control not found: ' + id);\n        }\n        return null;\n    };\n    /**\n     * Включить экземпляр управления панелью.\n     * @param {string} id - название экземпляра\n     * @returns {ControlManager} менеджер управления панелью\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.enable = function(id) {\n        if (this._controls.hasOwnProperty(id)) {\n            this._controls[id].enable();\n        } else {\n            console.log('ControlManager - enable - control not found: ' + id);\n        }\n        return this;\n    };\n    /**\n     * Выключить экземпляр управления панелью.\n     * @param {string} id - название экземпляра\n     * @returns {ControlManager} менеджер управления панелью\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.disable = function(id) {\n        if (this._controls.hasOwnProperty(id)) {\n            this._controls[id].disable();\n        } else {\n            console.log('ControlManager - disable - control not found: ' + id);\n        }\n        return this;\n    };\n\n    ControlManager.prototype._doAll = function(isEnable) {\n        var res = {};\n        for (var id in this._controls) {\n            if (this._controls.hasOwnProperty(id)) {\n                res[id] = this.isEnable(id);\n                if (isEnable) {\n                    this.enable(id);\n                } else {\n                    this.disable(id);\n                }\n            }\n        }\n        return res;\n    };\n    /**\n     * Выключить все экземпляры управления панелью.\n     * @returns {Object.<string, boolean>} Объект, сопоставляющий название экземпляра управления со значением,\n     * был ли этот экземпляр включен перед применением функции.\n     * @see {@link ControlManager#enableByValues}\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.disableAll = function() {\n        return this._doAll(false);\n    };\n    /**\n     * Включить все экземпляры управления панелью.\n     * @returns {Object.<string, boolean>} Объект, сопоставляющий название экземпляра управления со значением,\n     * был ли этот экземпляр включен перед применением функции.\n     * @see {@link ControlManager#enableByValues}\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.enableAll = function() {\n        return this._doAll(true);\n    };\n    /**\n     * Функция включения экземпляров управления панелью по маске включения\n     * @param {Object.<string, boolean>} values - Объект, сопоставляющий название экземпляра управления с флагом,\n     * включать ли данный экземпляр управления или выключать.\n     * @returns {ControlManager} менеджер управления панелью\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.enableByValues = function(values) {\n        for (var id in values) {\n            if (values.hasOwnProperty(id)) {\n                if (values[id]) {\n                    this.enable(id);\n                } else {\n                    this.disable(id);\n                }\n            }\n        }\n        return this;\n    };\n    /**\n     * Применить конфигурацию к панели. Применяет конфигурацию к списку экземпляров управления панелью.\n     * @param {Moving~config} config - конфигурация\n     * @memberOf ControlManager\n     * @see {@link IControl#configure}\n     */\n    ControlManager.prototype.configure = function(config) {\n        for (var name in this._controls) {\n            if (this._controls.hasOwnProperty(name)) {\n                this._controls[name].configure(config);\n            }\n        }\n    };\n\n    /**\n     * Уничтожить экземпляр ControlManager\n     * @memberOf ControlManager\n     */\n    ControlManager.prototype.destroy = function() {\n        this.disableAll();\n        this._controls = null;\n    };\n\n    return ControlManager;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/controlManager.js\n// module id = 10\n// module chunks = 0","define(['utils', 'IPlugin'], function(Utils, IPlugin) {\n    \"use strict\";\n\n    function ElementsPool(mainDiv, screenManager) {\n        this._mainDiv = mainDiv;\n        this._screenManager = screenManager;\n        this._elements = {};\n        this._elementsBySide = {};\n    }\n    Utils.inherite(ElementsPool, IPlugin);\n    ElementsPool.prototype.configure = function(config) {\n        if (typeof config === 'object') {\n            if (config.loadingHtml !== undefined) {\n                this._loadingHtml = config.loadingHtml;\n            }\n            if (config.saveHistoryInPool !== undefined) {\n                this._saveHistoryInPool = config.saveHistoryInPool;\n            }\n        }\n    };\n\n    // todo load зависит от prepare, поэтому из prepare надо возвращать функцию load\n    ElementsPool.prototype.prepareSide = function() {\n        function getScreen(side) {\n            return self._screenManager._getRelativeScreenByScreen(newScreen, side);\n        }\n        function prepareRelativeSide(side, screen) {\n            var id = screen.toString(),\n                element;\n            if (!self._elements.hasOwnProperty(id)) {\n                element = $('<div class=\"rb__side rb__hidden rb__loading\" data-id=\"' + id + '\">' + self._loadingHtml + '</div>');\n                self._mainDiv.prepend(element);\n                self._elements[id] = {\n                    element: element,\n                    screen: screen,\n                    state: 'loading'\n                };\n            } else {\n                element = self._elements[id].element;\n            }\n            if (side === 'center') {\n                element.toggleClass('rb__center', true);\n                element.toggleClass('rb__hidden', false);\n            }\n\n            self._elementsBySide[side] = id;\n        }\n\n        var newScreen = this._screenManager.getCurScreen(),\n            self = this,\n            leftScreen = getScreen('left'),\n            topScreen = getScreen('top'),\n            rightScreen = getScreen('right'),\n            bottomScreen = getScreen('bottom');\n\n        this.getElementBySide('center').toggleClass('rb__center', false);\n        this._mainDiv.find('>.rb__side').toggleClass('rb__hidden', true);\n\n        self._elementsBySide = {};\n        newScreen && prepareRelativeSide('center', newScreen);\n        leftScreen && prepareRelativeSide('left', leftScreen);\n        topScreen && prepareRelativeSide('top', topScreen);\n        rightScreen && prepareRelativeSide('right', rightScreen);\n        bottomScreen && prepareRelativeSide('bottom', bottomScreen);\n    };\n    ElementsPool.prototype.getElementBySide = function(side) {\n        var id = this._elementsBySide[side];\n        if (id) {\n            return this._elements[id].element;\n        } else {\n            return $();\n        }\n    };\n    ElementsPool.prototype.loadElements = function() {\n        var self = this;\n\n        Object.keys(this._elements).forEach(function(id) { // todo вынести forEach для объекта в utils\n            var elem = self._elements[id];\n\n            if (self._elementsBySide['center'] === id // todo стремная проверка, рефакторить\n                || self._elementsBySide['left'] === id\n                || self._elementsBySide['top'] === id\n                || self._elementsBySide['right'] === id\n                || self._elementsBySide['bottom'] === id) {\n                if (elem.state === 'loading') {\n                    elem.element.html(elem.screen.html());\n                    elem.element.toggleClass('rb__loading', false);\n                    elem.state = 'loaded';\n                }\n            } else {\n                if (elem.screen.isTemporary()) {\n                    if (!(self._saveHistoryInPool && self._screenManager._containsHistory(self._elements[id].screen))) {\n                        self._elements[id].element.remove();\n                        delete self._elements[id];\n                    }\n                }\n            }\n        });\n    };\n\n    ElementsPool.prototype.destroy = function() {\n        var self = this;\n        Object.keys(this._elements).forEach(function(id) {\n            self._elements[id].element.remove();\n        });\n        this._elements = null;\n        this._elementsBySide = null;\n        this._screenManager = null;\n    };\n\n    return ElementsPool;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/elementsPool.js\n// module id = 11\n// module chunks = 0","define(['utils', 'IControl', 'errors'], function(Utils, IControl, Errors) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Класс управления панелью с помощью клавиш на клавиатуре.\n     * @param {JQuery} mainDiv - элемент, в котором располагается панель. Должен содержать класс rb-wrapper.\n     * @param {function} actionFn - функция, определяющая действие при переходе в одну из сторон (Moving.prototype._moveByActionValue)\n     * @constructor KeydownControl\n     * @extends IControl\n     */\n    function KeydownControl(mainDiv, actionFn) {\n        if (!(mainDiv instanceof $)) {\n            throw new Errors.ArgumentError('mainDiv', mainDiv);\n        }\n\n        if (typeof actionFn !== 'function') {\n            throw new Errors.ArgumentError('actionFn', actionFn);\n        }\n        this._isEnable = false;\n        this._mainDiv = mainDiv;\n        this._actionFn = actionFn;\n    }\n    Utils.inherite(KeydownControl, IControl);\n    /**\n     * Применить конфигурацию. Учитывает опции leftKey, topKey, rightKey, bottomKey.\n     * @param {Moving~config} config\n     * @memberOf KeydownControl\n     */\n    KeydownControl.prototype.configure = function(config) {\n        if (typeof config === 'object') {\n            if (config.leftKey !== undefined) {\n                this._leftKey = config.leftKey;\n            }\n            if (config.topKey !== undefined) {\n                this._topKey = config.topKey;\n            }\n            if (config.rightKey !== undefined) {\n                this._rightKey = config.rightKey;\n            }\n            if (config.bottomKey !== undefined) {\n                this._bottomKey = config.bottomKey;\n            }\n        }\n    };\n    /**\n     *\n     * @returns {boolean}\n     * @memberOf KeydownControl\n     */\n    KeydownControl.prototype.isEnable = function() {\n        return this._isEnable;\n    };\n    /**\n     *\n     * @memberOf KeydownControl\n     */\n    KeydownControl.prototype.enable = function() {\n        if (this._isEnable) return;\n\n        var self = this;\n        var baseHandler = function(e) {\n            self._actionFn(e.which, [self._leftKey, self._topKey, self._rightKey, self._bottomKey], function(value, defValue) {\n                return value === defValue;\n            });\n            self._actionFn(e.key, [self._leftKey, self._topKey, self._rightKey, self._bottomKey], function(value, defValue) {\n                return value === defValue;\n            });\n            e.stopPropagation();\n        };\n        var mainDivHandler = function(e) {\n            baseHandler(e);\n        };\n\n        this._mainDiv.on('keydown', mainDivHandler);\n        this._mainDivHandler = mainDivHandler;\n\n        this._isEnable = true;\n    };\n    /**\n     *\n     * @memberOf KeydownControl\n     */\n    KeydownControl.prototype.disable = function() {\n        if (!this._isEnable) return;\n\n        this._mainDiv.off('keydown', this._mainDivHandler);\n        this._mainDivHandler = null;\n\n        this._isEnable = false;\n    };\n    /**\n     *\n     * @memberOf KeydownControl\n     */\n    KeydownControl.prototype.destroy = function() {\n        this.disable();\n    };\n\n    return KeydownControl;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/keydownControl.js\n// module id = 12\n// module chunks = 0","define(['errors', 'IPlugin', 'screenModel', 'animation', 'screenManager', 'baseDispatcher', 'controlManager', 'swipesControl', 'arrowsControl', 'keydownControl', 'elementsPool', 'utils'], function(\n    Errors, IPlugin, ScreenModel, Animation, ScreenManager, BaseDispatcher, ControlManager, SwipesControl, ArrowsControl, KeydownControl, ElementsPool, Utils) {\n    \"use strict\";\n\n    var sides = Utils.sidesWithCenter;\n\n    /**\n     * @class\n     * Класс управления панелью\n     * @param {JQuery} mainDiv - элемент, в котором располагается панель. Должен содержать класс rb-wrapper.\n     * @param {ScreenModel} startScreen - стартовая модель контента\n     * @constructor Moving\n     */\n    function Moving(mainDiv, startScreen) {\n        if (mainDiv instanceof $) {\n            this._mainDiv = mainDiv;\n        } else {\n            throw new Errors.ArgumentError('mainDiv', mainDiv);\n        }\n\n        /**\n         * Диспетчер, выполняющий зарегистрированные функции до выполнения перехода к новой ячейке в панели\n         * @name beforeMoveDispatcher\n         * @memberOf Moving#\n         */\n        this.beforeMoveDispatcher = new BaseDispatcher(mainDiv);\n        /**\n         * Диспетчер, выполняющий зарегистрированные функции до рендеринга контента моделей на странице после перехода\n         * @name beforeRenderDispatcher\n         * @memberOf Moving#\n         */\n        this.beforeRenderDispatcher = new BaseDispatcher(mainDiv);\n        /**\n         * Диспетчер, выполняющий зарегистрированные функции после рендеринга контента моделей на странице после перехода\n         * @name afterRenderDispatcher\n         * @memberOf Moving#\n         */\n        this.afterRenderDispatcher = new BaseDispatcher(mainDiv);\n        this._screenManager = new ScreenManager();\n        this._elementsPool = new ElementsPool(mainDiv, this._screenManager);\n        this._animation = new Animation(mainDiv, this._elementsPool);\n        this._controlManager = new ControlManager();\n        if (Utils.isMobile) {\n            this._controlManager\n                .add('swipes', new SwipesControl(mainDiv,this._moveByActionValue.bind(this)));\n        } else {\n            this._controlManager\n                .add('arrows', new ArrowsControl(mainDiv, this._moveByActionValue.bind(this), this.afterRenderDispatcher))\n                .add('keyboard', new KeydownControl(mainDiv, this._moveByActionValue.bind(this)));\n        }\n\n        this._plugins = [];\n\n        this.resetConfig();\n        this._loadingPromise = this.setScreen(startScreen || ScreenModel.getMainScreen(), false);\n        this._controlManager.enableAll();\n        //if (mainDiv.length) {\n        //    mainDiv[0].moving = this;\n        //}\n\n        var self = this;\n\n        this._clickHandler = function(e) {\n            if ($(e.target).closest('.rb').length && !$(document.activeElement).closest('.rb').length) {\n                self.activate();\n            }\n        };\n        mainDiv.on('click', this._clickHandler);\n\n        this._relativeUpdateFn = this._reloadScreen.bind(this);\n        ScreenModel.registerUpdateFn(this._relativeUpdateFn);\n    }\n\n    /**\n     * Сбросить конфигурацию панели к значению по умолчанию (какое именно - см. в коде).\n     * @memberOf Moving\n     */\n    Moving.prototype.resetConfig = function() {\n        this.configure({\n            wrongTime1: 500,\n            wrongTime2: 500,\n            correctTime: 1000,\n            wrongEasing1: 'easeInExpo',\n            wrongEasing2: 'easeOutElastic',\n            correctEasing: 'easeOutExpo',\n            hideArrowsAfterTime: true,\n            hideArrowsTime: 2000,\n            showArrowsOutside: true,\n            showArrowsOnHover: true,\n            loadingHtml: '<div class=\"rb__loading_wrapper\"><div class=\"rb__loader\"></div></div>',\n            //http://www.javascripter.net/faq/keycodes.htm\n            //https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\n            leftKey: [37, 'a'],\n            topKey: [38, 'w'],\n            rightKey: [39, 'd'],\n            bottomKey: [40, 's'],\n            maxHistoryLength: 10,\n            lockControls: false,\n            showAdjacentScreens: true,\n            saveHistoryInPool: false,\n            pointersForSwipe: 1,\n            isDirectPath: true,\n            savePrevious: true,\n\n            cyclicStep: true,\n\n            getRight: function(screen) {\n                var childIndex = screen.defaultChildIndex();\n                //this._lastScreen = screen; // todo эта логика нужна здесь а не так где она сейчас, чтобы все было инкапсулировано в эти функции\n                //this._lastSide = 'right';\n                return screen.getChild(childIndex);\n            },\n            getLeft: function(screen) {\n                var parentIndex = screen.defaultParentIndex();\n                //this._lastScreen = screen;\n                //this._lastSide = 'left';\n                return screen.getParent(parentIndex);\n            },\n            getTop: function(screen, cyclicStep) {\n                function getNextIndex(index, length) {\n                    return cyclicStep ? Utils.cycledNumber(index - 1, length) : (index - 1);\n                }\n                var index;\n                if (this._lastSide === 'left') {\n                    index = this._lastScreen.getParentIndex(screen);\n                    return this._lastScreen.getParent(getNextIndex(index, this._lastScreen.parentsLength()));\n                }\n                if (this._lastSide === 'right') {\n                    index = this._lastScreen.getChildIndex(screen);\n                    return this._lastScreen.getChild(getNextIndex(index, this._lastScreen.childrenLength()));\n                }\n                var parent = this._getLeft(screen);\n                if (parent) {\n                    index = parent.getChildIndex(screen);\n                    return parent.getChild(getNextIndex(index, parent.childrenLength()));\n                }\n                var child = this._getRight(screen);\n                if (child) {\n                    index = child.getParentIndex(screen);\n                    return child.getParent(getNextIndex(index, child.parentsLength()));\n                }\n            },\n            getBottom: function(screen, cyclicStep) {\n                function getNextIndex(index, length) {\n                    return cyclicStep ? Utils.cycledNumber(index + 1, length) : (index + 1);\n                }\n                var index;\n                if (this._lastSide === 'left') {\n                    index = this._lastScreen.getParentIndex(screen);\n                    return this._lastScreen.getParent(getNextIndex(index, this._lastScreen.parentsLength()));\n                }\n                if (this._lastSide === 'right') {\n                    index = this._lastScreen.getChildIndex(screen);\n                    return this._lastScreen.getChild(getNextIndex(index, this._lastScreen.childrenLength()));\n                }\n                var parent = this._getLeft(screen);\n                if (parent) {\n                    index = parent.getChildIndex(screen);\n                    return parent.getChild(getNextIndex(index, parent.childrenLength()));\n                }\n                var child = this._getRight(screen);\n                if (child) {\n                    index = child.getParentIndex(screen);\n                    return child.getParent(getNextIndex(index, child.parentsLength()));\n                }\n            }\n        });\n    };\n    /**\n     * @typedef {function} Moving~getLeft\n     * Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход влево.\n     * По умолчанию берет опцию defaultParentIndex у экземпляра ScreenModel и ищет предка модели с этим индексом.\n     * @param {ScreenModel} screen - текущая модель контента панели\n     */\n    /**\n     * @typedef {function} Moving~getTop\n     * Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход вверх.\n     * По умолчанию смотрит, осуществлялись ли переходы влево-вправо,\n     * если последним таким был переход вправо, то берется модель, из которой был сделан шаг вправо и в контексте ее потомков\n     * от текущего потомка будет найден предыдущий потомок и возвращен в качестве результата.\n     * Если при этом стоит опция cyclicStep = true, то в случае самого верхнего потомка следующим будет возвращен самый нижний потомок.\n     * Если последним был переход влево, то берется модель, из которой был сделан шаг влево и в контексте ее предков\n     * от текущего предка будет найден предыдущий предок и возвращен в качестве результата.\n     * Если при этом стоит опция cyclicStep = true, то в случае самого верхнего предка следующим будет возвращен самый нижний предок.\n     * А если переходов влево-вправо не было, будет считаться, будто бы был сделан переход вправо, а если и это не помогло,\n     * будет считаться, будто был сделан переход влево.\n     * Если у модели нет предков, следующая модель не будет найдена.\n     * @param {ScreenModel} screen - текущая модель контента панели\n     * @param {boolean} cyclicStep - делать ли цикличный переход в контексте массива моделей, в котором будет искаться новая модель.\n     */\n    /**\n     * @typedef {function} Moving~getRight\n     * Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход вправо.\n     * По умолчанию берет опцию defaultChildIndex у экземпляра ScreenModel и ищет потомка модели с этим индексом.\n     * @param {ScreenModel} screen - текущая модель контента панели\n     */\n    /**\n     * @typedef {function} Moving~getBottom\n     * Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход вниз.\n     * По умолчанию смотрит, осуществлялись ли переходы влево-вправо,\n     * если последним таким был переход вправо, то берется модель, из которой был сделан шаг вправо и в контексте ее потомков\n     * от текущего потомка будет найден следующий потомок и возвращен в качестве результата.\n     * Если при этом стоит опция cyclicStep = true, то в случае самого нижнего потомка следующим будет возвращен самый верхний потомок.\n     * Если последним был переход влево, то берется модель, из которой был сделан шаг влево и в контексте ее предков\n     * от текущего предка будет найден следующий предок и возвращен в качестве результата.\n     * Если при этом стоит опция cyclicStep = true, то в случае самого нижнего предка следующим будет возвращен самый верхний предок.\n     * А если переходов влево-вправо не было, будет считаться, будто бы был сделан переход вправо, а если и это не помогло,\n     * будет считаться, будто был сделан переход влево.\n     * Если у модели нет предков, следующая модель не будет найдена.\n     * @param {ScreenModel} screen - текущая модель контента панели\n     * @param {boolean} cyclicStep - делать ли цикличный переход в контексте массива моделей, в котором будет искаться новая модель.\n     */\n    /**\n     * Конфигурация панели\n     * @typedef {Object} Moving~config\n     * @property {number} [wrongTime1] - Время, затрачиваемое на первую часть неудачного перехода\n     * @property {number} [wrongTime2] - Время, затрачиваемое на вторую часть неудачного перехода\n     * @property {number} [correctTime] - Время, затрачиваемое на удачный переход\n     * @property {string} [wrongEasing1] - Анимация первой части неудачного перехода.<br> jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/\n     * @property {string} [wrongEasing2] - Анимация второй части неудачного перехода.<br> jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/\n     * @property {string} [correctEasing] - Анимация удачного перехода.<br> jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/\n     * @property {boolean} [hideArrowsAfterTime] - Скрывать ли стрелки перемещения после некоторого времени, чтобы можно было нажимать на элементы, которые находятся под этими стрелками.\n     * @property {number} [hideArrowsTime] - Через какой промежуток времени скрывать стрелки перемещения\n     * @property {boolean} [showArrowsOutside] - Показывать ли стрелки перемещения снаружи от панели (иначе показывать внутри панели)\n     * @property {boolean} [showArrowsOnHover] - Показывать ли стрелки при наведении мыши (иначе показывать всегда)\n     * @property {string|null} [loadingHtml] - Верстка ожидания, показываемая во время, пока контент еще не был вставлен в панель\n     * @property {(string|number|Array.<string|number>)} [leftKey] - Клавиши, при нажатии на которые будет сделан переход влево.\n     * Могут использоваться строковые или числовые нотации клавиш.<br>\n     * http://www.javascripter.net/faq/keycodes.htm<br>\n     * https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes\n     * @property {(string|number|Array.<string|number>)} [topKey] - Клавиши, при нажатии на которые будет сделан переход вверх.\n     * @property {(string|number|Array.<string|number>)} [rightKey] - Клавиши, при нажатии на которые будет сделан переход вправо.\n     * @property {(string|number|Array.<string|number>)} [bottomKey] - Клавиши, при нажатии на которые будет сделан переход вниз.\n     * @property {number} [maxHistoryLength] - Максимальная длина хранимой истории удачных переходов.\n     * @property {boolean} [lockControls] - Заблокированы ли элементы управления переходами, пока происходит анимация перехода (любые способы управления).\n     * @property {boolean} [showAdjacentScreens] - Отображать ли старую ячейку при анимации перехода на новую ячейку панели.\n     * @property {boolean} [saveHistoryInPool] - Хранить ли верстку ячеек панели, которые хранятся в истории переходов.\n     * @property {number} [pointersForSwipe] - Количество пальцев, необходимых для свайпа при переходе на новую ячейку на мобильных устройствах.\n     * @property {boolean} [isDirectPath] - Использовать ли при поиске кратчайшего пути до указанной модели только переходы\n     * от потомков к предкам и от предков к потомкам (иначе переходы по массивам предков и по массивам потомков тоже будут считаться отдельными переходами)\n     * @property {boolean} [savePrevious] - сохранять ли предков (если шаг в сторону потомка) и потомков (если шаг в сторону предка), с которых был сделан переход,\n     * чтобы в дальнейшем вернутся в них при переходе обратно с ячейки, в которую был сделан переход.\n     * @property {boolean} [cyclicStep] - делать ли цикличный переход в контексте массива моделей, в котором будет искаться новая модель.\n     * @property {Moving~getRight} [getRight] - Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход вправо\n     * @property {Moving~getLeft} [getLeft] - Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход влево\n     * @property {Moving~getTop} [getTop] - Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход вверх\n     * @property {Moving~getBottom} [getBottom] - Функция, задающая алгоритм поиска ячейки, в которую должен быть осуществлен переход вниз\n     */\n    /**\n     * Применить конфигурацию к панели\n     * @param {Moving~config} config - конфигурация\n     * @memberOf Moving\n     */\n    Moving.prototype.configure = function(config) {\n        if (!config) return;\n\n        this._plugins.forEach(function(plugin) {\n            plugin.configure(config);\n        });\n\n        this._animation.configure(config);\n        this._elementsPool.configure(config);\n        this._screenManager.configure(config);\n        this._controlManager.configure(config);\n\n        if (config.loadingHtml) {\n            config.loadingDiv = '<div class=\"rb__loading\">' + config.loadingHtml + '</div>';\n        } else if (config.loadingHtml === null) {\n            config.loadingDiv = '';\n        }\n\n        this.beforeMoveDispatcher.configure(config);\n        this.beforeRenderDispatcher.configure(config);\n        this.afterRenderDispatcher.configure(config);\n\n        if (typeof config === 'object') {\n            if (config.lockControls !== undefined) {\n                this._lockControls = config.lockControls;\n            }\n        }\n\n        // updates internal state\n        if (this._screenManager.getCurScreen()) { // todo то есть если только это не new Moving иначе еще рано да и не надо\n            this._reloadScreen();\n        }\n    };\n\n    // todo defineProperty, и вообще доступ к объектам в api сделать через defineProperty\n    /**\n     * Получить менеджер управления\n     * @returns {ControlManager} ControlManager\n     * @memberOf Moving\n     */\n    Moving.prototype.getControlManager = function() {\n        return this._controlManager;\n    };\n    /**\n     * Получить менеджер моделей контента\n     * @returns {ScreenManager} ScreenManager\n     * @memberOf Moving\n     */\n    Moving.prototype.getScreenManager = function() {\n        return this._screenManager;\n    };\n\n    /**\n     * Осуществить переход в указанную сторону.\n     * @param {string} side - сторона, в которую осуществляется переход\n     * @param {Boolean} [isSaveHistory] - сохранять ли осуществляемый переход в историю переходов\n     * @returns {Promise|undefined} promise о завершении действия, либо undefined, если переход не требуется\n     * @memberOf Moving\n     */\n    Moving.prototype.move = function(side, isSaveHistory) {\n        var self = this,\n            screen = this._screenManager.getCurScreen();\n        if (side) {\n            return Promise.race([ this.beforeMoveDispatcher.runActions(\n                self._moveInner.bind(self, side, screen, isSaveHistory),\n                [side, self._screenManager.getCurScreen(), self]\n            ) ]);\n        }\n    };\n    Moving.prototype._moveInner = function(side, screen, isSaveHistory) {\n        var self = this;\n\n        if (this._lockControls && !this._locks) {\n            this._locks = this._controlManager.disableAll();\n        }\n\n        this._screenManager._updateScreens('center', screen, isSaveHistory);\n\n        return new Promise(function (moveResolve, moveReject) {\n\n            if (!self._screenManager.getRelativeScreen(side)) {\n                self._animation.goToWrongSide(side).then(function(result) {\n                    if (result) {\n                        self._renderHtml(side, moveResolve.bind(undefined, {\n                            how: 'wrongSide',\n                            isOk: result\n                        }));\n                    }\n                });\n            } else if (side === 'center') {\n                self._elementsPool.prepareSide();\n                self._animation.goToCenter();\n                self._renderHtml(side, moveResolve.bind(undefined, {\n                    how: 'center',\n                    isOk: true\n                }));\n            } else if (sides.indexOf(side) !== -1) {\n                if (side === 'left' || side === 'right') {\n                    self._screenManager._lastSide = side; // todo надо инкапсулировать\n                    self._screenManager._lastScreen = self._screenManager.getCurScreen();\n                }\n\n                self._screenManager._updateScreens(side, undefined, isSaveHistory);\n                self._elementsPool.prepareSide();\n\n                self._animation.goToCorrectSide(side).then(function(result) {\n                    if (result) {\n                        self._renderHtml(side, moveResolve.bind(undefined, {\n                            how: 'correctSide',\n                            isOk: result\n                        }));\n                    }\n                });\n            } else {\n                moveReject(new Errors.ArgumentError('side', side));\n            }\n        });\n    };\n    Moving.prototype._moveByActionValue = function(value, ltrbValues, mapFn) {\n        function check(value, checkValues) {\n            var res;\n            if (Array.isArray(checkValues)) {\n                res = checkValues.find(function(checkValue) {\n                    return mapFn(value, checkValue);\n                });\n                res = res !== undefined;\n            } else {\n                res = mapFn(value, checkValues);\n            }\n            return res;\n        }\n\n        var side;\n        if (check(value, ltrbValues[0])) side = 'left';\n        else if (check(value, ltrbValues[1])) side = 'top';\n        else if (check(value, ltrbValues[2])) side = 'right';\n        else if (check(value, ltrbValues[3])) side = 'bottom';\n        return this.move(side);\n    };\n\n    /**\n     * Осуществить откат последнего удачного хода, воспользовавшись историей переходов.\n     * @returns {Promise|undefined} promise о завершении действия, либо undefined, если переход не требуется\n     * @memberOf Moving\n     */\n    Moving.prototype.moveBack = function() {\n        var lastStep = this._screenManager.popHistory();\n        if (lastStep) {\n\n            var curScreen = this._screenManager.getCurScreen(),\n                nextScreen = lastStep.screen,\n                side = lastStep.side,\n                mustUpdate = false;\n            if (side === 'left' && curScreen.getParent(nextScreen)) { // todo неправильно! нельзя затачиваться на структуру\n                mustUpdate = true;\n            } else if (side === 'right' && curScreen.getChild(nextScreen)) {\n                mustUpdate = true;\n            } else if (side === 'bottom' && this._screenManager._getBottom(curScreen, this._screenManager._cyclicStep) === nextScreen) {\n                mustUpdate = true;\n            } else if (side === 'top' && this._screenManager._getTop(curScreen, this._screenManager._cyclicStep) === nextScreen) {\n                mustUpdate = true;\n            } else {\n                return null;\n            }\n            if (mustUpdate) {\n                this._screenManager._setRelativeScreen(this._screenManager.getCurScreen(), side, nextScreen);\n            }\n\n            var self = this;\n            if (side) {\n                return Promise.race([ this.beforeMoveDispatcher.runActions(\n                    self._moveInner.bind(self, lastStep.side, curScreen, false),\n                    [side, self._screenManager.getCurScreen(), self]\n                ) ]);\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Анимировать запрещенное перемещение в одну из сторон. В панели в эту сторону перемещение может быть запрещено,\n     * но будет анимировано, будто запрещено.\n     * @param {string} side - сторона, в которую осуществляется переход\n     * @returns {Promise} promise о завершении действия\n     * @memberOf Moving\n     */\n    Moving.prototype.animateWrongSide = function(side) {\n        return this._animation.goToWrongSide(side);\n    };\n\n    /**\n     * Установить модель контента в текущую ячейку панели.\n     * @param {ScreenModel} screen - Устанавливаемая модель контента\n     * @param {Boolean} [isSaveHistory] - Сохранять ли устанавливаемую модель в историю переходов\n     * @returns {Promise} promise о завершении установки модели\n     * @memberOf Moving\n     */\n    Moving.prototype.setScreen = function(screen, isSaveHistory) {\n        var self = this;\n        return Promise.race([ this.beforeMoveDispatcher.runActions(\n            self._moveInner.bind(self, 'center', screen, isSaveHistory),\n            ['center', self._screenManager.getCurScreen(), self]\n        ) ]);\n    };\n    // todo это слишком много, нужно выделить тот функционал который реально релоадит, и вызывать его везде в том числе в ините где сейчас дергается move\n    Moving.prototype._reloadScreen = function() {\n        return this.setScreen(this._screenManager.getCurScreen(), false);\n    };\n\n    /**\n     * Перезагрузить все панели на странице. Перезагрузка предполагает обновление верстки ячейки панели,\n     * сброс состояния в верстке. Если в элементах верстки есть подписки, необходимо позаботиться об отписке и\n     * последующей подписке к новым элементам верстки.\n     * @prop {string} side - сторона, с которой будет перезагружаться ячейка панели относительно текущей ячейки.\n     * @memberOf Moving\n     */\n    Moving.prototype.reload = function(side) {\n        side = side || 'center';\n        var rbSide = this._elementsPool.getElementBySide(side);\n        var screen = this._screenManager.getRelativeScreen(side);\n        rbSide.html(screen.html());\n    };\n\n    Moving.prototype._renderHtml = function(side, moveResolve) {\n        var self = this,\n            args = [side, self._screenManager.getCurScreen(), self];\n\n        function afterRender() {\n            self.activate();\n            self.afterRenderDispatcher.runActions(Utils.nop, args);\n            if (self._lockControls) {\n                self._controlManager.enableByValues(self._locks);\n                self._locks = null;\n            }\n            moveResolve();\n        }\n\n        this.beforeRenderDispatcher.runActions(function() {\n            var iframeCount, loadedIframeCount = 0, iframes;\n\n            iframes = self._mainDiv.find('iframe');\n            self._elementsPool.loadElements();\n            iframes = self._mainDiv.find('iframe').not(iframes);\n\n            iframeCount = iframes.length;\n            iframes.one('load', function() {\n                loadedIframeCount++;\n                if (iframeCount === loadedIframeCount) {\n                    afterRender();\n                }\n            });\n\n            setTimeout(function() {\n                if (iframeCount === 0) {\n                    afterRender();\n                }\n            }, 0);\n        }, args);\n    };\n\n    /**\n     * Активировать панель. Переводит фокус на панель, и, как следствие, панель ловит все события нажатия клавиш.\n     * @memberOf Moving\n     */\n    Moving.prototype.activate = function() {\n        this._mainDiv.find('>.rb__fake-element').focus();\n    };\n\n    /**\n     * Находит кратчайший путь до указанной модели и пошагово переходит от текущей ячейки к той ячейке, в которой располагается найденная модель.\n     * @param {ScreenModel} toScreen - Искомая модель контента\n     * @returns {Promise} promise о завершении переходов к намеченной цели\n     * @memberOf Moving\n     */\n    Moving.prototype.goToScreen = function(toScreen) {\n        function firstStep(path) {\n            return new Promise(function(resolve, reject) {\n                nextStep(path, 0, resolve, reject);\n            });\n        }\n        function nextStep(path, i, resolve, reject) {\n            if (!path) {\n                self._controlManager.enableByValues(locks);\n                reject(new Errors.PathNotFoundError(fromScreen, toScreen));\n                return;\n            }\n            if (i === path.length - 1) {\n                self._controlManager.enableByValues(locks);\n                resolve();\n                return;\n            }\n            if ( i > path.length - 1) {\n                self._controlManager.enableByValues(locks);\n                reject(new Errors.FatalError('goToScreen : i > path.length - 1'));\n                return;\n            }\n\n            var curScreen = path[i],\n                nextScreen = path[i+1],\n                side;\n\n            if (curScreen.getParent(nextScreen)) { // todo неправильно! нельзя затачиваться на структуру\n                side = 'left';\n            } else if (curScreen.getChild(nextScreen)) {\n                side = 'right';\n            } else if (self._screenManager._getBottom(curScreen, self._screenManager._cyclicStep) === nextScreen) {\n                side = 'bottom';\n            } else if (self._screenManager._getTop(curScreen, self._screenManager._cyclicStep) === nextScreen) {\n                side = 'top';\n            } else {\n                self._controlManager.enableByValues(locks);\n                reject(new Errors.FatalError('goToScreen : side not found'));\n            }\n\n            self._screenManager._setRelativeScreen(self._screenManager.getCurScreen(), side, nextScreen);\n\n            self.afterRenderDispatcher.add(function() {\n                self.afterRenderDispatcher.add(function() {\n                    nextStep(path, i+1, resolve, reject);\n                }, true);\n                self.move(side);\n            }, true);\n\n            self.setScreen(curScreen, false);\n        }\n        var self = this,\n            locks = this._controlManager.disableAll(),\n            fromScreen = this._screenManager.getCurScreen(),\n            path = this._screenManager.findShortestPath(fromScreen, toScreen);\n\n        return firstStep(path);\n    };\n\n    /**\n     * Добавить плагин, расширяющий функционал панели, к общему списку плагинов.\n     * @param {IPlugin} plugin - добавляемый плагин\n     * @memberOf Moving\n     */\n    Moving.prototype.addPlugin = function(plugin) {\n        if (plugin instanceof IPlugin) {\n            this._plugins.push(plugin);\n        } else {\n            console.error('Moving - addPlugin - argument must be IPlugin');\n        }\n    };\n    /**\n     * Удалить плагин из общего списка плагинов\n     * @param {IPlugin} plugin - удаляемый плагин\n     * @memberOf Moving\n     */\n    Moving.prototype.removePlugin = function(plugin) {\n        var index = this._plugins.indexOf(plugin);\n        if (index != -1) {\n            plugin.destroy();\n            this._plugins.splice(index, 1);\n        }\n    };\n\n    /**\n     * Уничтожить панель\n     * @memberOf Moving\n     */\n    Moving.prototype.destroy = function() {\n        ScreenModel.unregisterUpdateFn(this._relativeUpdateFn);\n\n        this._plugins.forEach(function(plugin) {\n            plugin.destroy();\n        });\n\n        this.beforeMoveDispatcher.destroy();\n        this.beforeRenderDispatcher.destroy();\n        this.afterRenderDispatcher.destroy();\n        this._animation.destroy();\n        this._controlManager.destroy();\n        this._screenManager.destroy();\n        this._elementsPool.destroy();\n        this._animation = null;\n        this._elementsPool = null;\n        this._screenManager = null;\n        this._controlManager = null;\n        this.beforeMoveDispatcher = null;\n        this.beforeRenderDispatcher = null;\n        this.afterRenderDispatcher = null;\n\n        this._mainDiv.off('click', this._clickHandler);\n        this._mainDiv.remove();\n    };\n\n    return Moving;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/moving.js\n// module id = 13\n// module chunks = 0","define(['utils', 'screenModel', 'IPlugin', 'errors'], function(Utils, Screen, IPlugin, Errors) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Класс-менеджер моделей контента\n     * @constructor ScreenManager\n     * @extends IPlugin\n     */\n    function ScreenManager() {\n        this._history = [];\n        this._curScreen = null;\n        this._relativeScreens = {};\n        this._relativeUpdateFn = this._updateRelativeScreen.bind(this);\n        Screen.registerUpdateFn(this._relativeUpdateFn);\n    }\n    Utils.inherite(ScreenManager, IPlugin);\n    /**\n     * Применить конфигурацию к панели. Учитывает опции maxHistoryLength, isDirectPath, cyclicStep, getLeft, getTop, getRight, getBottom.\n     * @param {Moving~config} config - конфигурация\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.configure = function(config) {\n        if (typeof config === 'object') {\n            if (config.maxHistoryLength !== undefined) {\n                if (typeof config.maxHistoryLength === 'number' && config.maxHistoryLength >= 0) {\n                    this._maxHistoryLength = config.maxHistoryLength;\n                } else {\n                    throw new Errors.ArgumentError('maxHistoryLength', config.maxHistoryLength);\n                }\n            }\n            if (config.isDirectPath !== undefined) {\n                this._isDirectPath = config.isDirectPath;\n            }\n            if (config.cyclicStep !== undefined) {\n                this._cyclicStep = config.cyclicStep;\n            }\n            if (config.getLeft !== undefined) {\n                this._getLeft = config.getLeft;\n            }\n            if (config.getRight !== undefined) {\n                this._getRight = config.getRight;\n            }\n            if (config.getTop !== undefined) {\n                this._getTop = config.getTop;\n            }\n            if (config.getBottom !== undefined) {\n                this._getBottom = config.getBottom;\n            }\n            if (config.savePrevious !== undefined) {\n                this._savePrevious = config.savePrevious;\n            }\n\n        }\n    };\n\n    ScreenManager.prototype._updateScreens = function(side, screen, isSaveHistory) {\n        var updated = false;\n        if (screen) {\n            if (this._curScreen !== screen) {\n                updated = true;\n            }\n            this._curScreen = screen;\n        } else if (this.getRelativeScreen(side)) {\n            var prevScreen = this._curScreen;\n            this._curScreen = this.getRelativeScreen(side);\n\n            if (side !== 'center') {\n                if (this._savePrevious) {\n                    this._setRelativeScreen(this._curScreen, Utils.oppositeSide(side), prevScreen);\n                }\n                updated = true;\n            }\n        }\n\n        if (updated && isSaveHistory !== false) {\n            this._history.push({\n                screen: prevScreen,\n                side: Utils.oppositeSide(side),\n                lastSide: this._lastSide,\n                lastScreen: this._lastScreen\n            });\n            if (this._history.length > this._maxHistoryLength) {\n                this._history.shift();\n            }\n        }\n\n        return this._curScreen;\n    };\n\n    ScreenManager.prototype._getRelativeScreenByScreen = function(screen, side) {\n        if (!(screen instanceof Screen)) {\n            throw new Errors.ArgumentError('screen', screen);\n        }\n        if (Utils.sidesWithCenter.indexOf(side) === -1) {\n            throw new Errors.ArgumentError('side', side);\n        }\n\n        var id = screen.toString();\n        if (!this._relativeScreens[id]) {\n            this._relativeScreens[id] = {};\n        }\n\n        if (side === 'center') {\n            return screen;\n        } else if (side === 'left') {\n            return this._relativeScreens[id]['left'] || this._getLeft(screen);\n        } else if (side === 'top') {\n            return this._relativeScreens[id]['top'] || this._getTop(screen, this._cyclicStep);\n        } else if (side === 'right') {\n            return this._relativeScreens[id]['right'] || this._getRight(screen);\n        } else if (side === 'bottom') {\n            return this._relativeScreens[id]['bottom'] || this._getBottom(screen, this._cyclicStep);\n        }\n        return null;\n    };\n    ScreenManager.prototype._setRelativeScreen = function(baseScreen, side, screen) {\n        if (Utils.sides.indexOf(side) === -1) {\n            throw new Errors.ArgumentError('side', side);\n        }\n        if (!(baseScreen instanceof Screen)) {\n            throw new Errors.ArgumentError('baseScreen', baseScreen);\n        }\n        if (!(screen instanceof Screen)) {\n            throw new Errors.ArgumentError('screen', screen);\n        }\n\n        var id = baseScreen.toString();\n        if (!this._relativeScreens[id]) {\n            this._relativeScreens[id] = {};\n        }\n\n        this._relativeScreens[id][side] = screen;\n    };\n    ScreenManager.prototype._updateRelativeScreen = function(screen) {\n        if (!(screen instanceof Screen)) {\n            throw new Errors.ArgumentError('screen', screen);\n        }\n        var id = screen.toString();\n\n        if (!this._relativeScreens[id]) {\n            this._relativeScreens[id] = {};\n        }\n\n        if (!this._getRight(screen)) {\n            this._relativeScreens[id]['right'] = undefined;\n        }\n        if (!this._getLeft(screen)) {\n            this._relativeScreens[id]['left'] = undefined;\n        }\n        if (!this._getBottom(screen, this._cyclicStep)) {\n            this._relativeScreens[id]['bottom'] = undefined;\n        }\n        if (!this._getTop(screen, this._cyclicStep)) {\n            this._relativeScreens[id]['top'] = undefined;\n        }\n    };\n\n    /**\n     * Возвращает модель текущей ячейки панели.\n     * @returns {ScreenModel|null} модель текущей ячейки панели\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.getCurScreen = function() {\n        return this._curScreen;\n    };\n    /**\n     * Возвращает модель, располагающуюся рядом с текущей ячейкой панели.\n     * @param {string} side - сторона относительно текущей ячейки\n     * @returns {ScreenModel|null} модель текущей ячейки панели\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.getRelativeScreen = function(side) {\n        return this._getRelativeScreenByScreen(this._curScreen, side);\n    };\n    /**\n     * Очистить историю перемещений в панели.\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.clearHistory = function() {\n        this._history = [];\n    };\n    /**\n     * Удаляет из истории перемещений последнее удачное перемещение в панели и возвращает модель, которая располагается в последней посещенной ячейке из истории.\n     * @returns {ScreenModel} Модель из последнего удачного перемещения в истории\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.popHistory = function() {\n        var res = this._history.pop();\n        if (res) {\n            this._lastSide = res.lastSide;\n            this._lastScreen = res.lastScreen;\n        } else {\n            this._lastSide = null;\n            this._lastScreen = null;\n        }\n        return res;\n    };\n    ScreenManager.prototype._containsHistory = function(screen) {\n        return this._history.some(function(val) {\n            return val.screen === screen;\n        });\n    };\n\n    /**\n     * Поиск кратчайшего пути от одной модели до другой. Если для разных ячеек панели используются одинаковые модели, результат непредсказуем.\n     * @param {ScreenModel} start - Модель, от которой начинает поиск пути\n     * @param {ScreenModel} end - Конечная модель, в которую ищется путь\n     * @returns {null|ScreenModel[]} Путь от начальной модели до конечной модели в панели\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.findShortestPath = function (start, end) {\n        function findPaths(start, end) {\n            var costs = {},\n                open = {'0': [start]},\n                predecessors = {},\n                keys;\n\n            var addToOpen = function (cost, vertex) {\n                if (!open[cost]) open[cost] = [];\n                open[cost].push(vertex);\n            };\n\n            costs[start] = 0;\n\n            while (open) {\n                if(!(keys = Object.keys(open)).length) break;\n\n                keys.sort(function (a, b) {\n                    return a - b;\n                });\n\n                var key = keys[0],\n                    bucket = open[key],\n                    node = bucket.shift(),\n                    currentCost = +key,\n                    adjacentNodes;\n\n                if (self._isDirectPath) {\n                    adjacentNodes = node && node._children\n                            .concat(node._parents)// todo если оставить только children будет настоящий поиск в графе\n                            .concat(self._getRelativeScreenByScreen(node, 'top'))\n                            .concat(self._getRelativeScreenByScreen(node, 'bottom')) || [];\n                } else {\n                    adjacentNodes = node && [self._getRelativeScreenByScreen(node, 'left'),\n                            self._getRelativeScreenByScreen(node, 'top'),\n                            self._getRelativeScreenByScreen(node, 'right'),\n                            self._getRelativeScreenByScreen(node, 'bottom')\n                        ] || [];\n                }\n\n                if (!bucket.length) delete open[key];\n\n                for (var i = 0; i < adjacentNodes.length; i++) {\n                    var vertex = adjacentNodes[i],\n                        totalCost = currentCost + 1,\n                        vertexCost = costs[vertex];\n\n                    if ((vertexCost === undefined) || (vertexCost > totalCost)) {\n                        costs[vertex] = totalCost;\n                        addToOpen(totalCost, vertex);\n                        predecessors[vertex] = node;\n                    }\n                }\n            }\n\n            if (costs[end] === undefined) {\n                return null;\n            } else {\n                return predecessors;\n            }\n        }\n        function extractShortest(predecessors, end) {\n            var nodes = [],\n                u = end;\n\n            while (u) {\n                nodes.push(u);\n                u = predecessors[u];\n            }\n\n            nodes.reverse();\n            return nodes;\n        }\n\n        var self = this;\n        var predecessors = findPaths(start, end);\n        return !predecessors ? null : extractShortest(predecessors, end);\n    };\n\n    /**\n     * Уничтожить ScreenManager\n     * @memberOf ScreenManager\n     */\n    ScreenManager.prototype.destroy = function() {\n        Screen.unregisterUpdateFn(this._relativeUpdateFn);\n        this._history = null;\n        this._curScreen = null;\n        this._relativeScreens = null;\n    };\n\n    return ScreenManager;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/screenManager.js\n// module id = 14\n// module chunks = 0","define(['utils', 'IControl', 'errors', 'hammer'], function(Utils, IControl, Errors, Hammer) {\n    \"use strict\";\n\n    /**\n     * @class\n     * Класс управления панелью на мобильных устройствах с помощью свайпов.\n     * @param {JQuery} mainDiv - элемент, в котором располагается панель. Должен содержать класс rb-wrapper.\n     * @param {function} actionFn - функция, определяющая действие при переходе в одну из сторон (Moving.prototype._moveByActionValue)\n     * @constructor SwipesControl\n     * @extends IControl\n     */\n    function SwipesControl(mainDiv, actionFn) {\n        if (!(mainDiv instanceof $)) {\n            throw new Errors.ArgumentError('mainDiv', mainDiv);\n        }\n\n        if (typeof actionFn !== 'function') {\n            throw new Errors.ArgumentError('actionFn', actionFn);\n        }\n        this._isEnable = false;\n        this._mainDiv = mainDiv;\n        this._actionFn = actionFn;\n\n        this._hammertime = new Hammer(mainDiv[0]);\n        this._hammertime.get('swipe').set({direction: Hammer.DIRECTION_ALL});\n    }\n    Utils.inherite(SwipesControl, IControl);\n    /**\n     * Применить конфигурацию. Учитывает опцию pointersForSwipe.\n     * @param {Moving~config} config\n     * @memberOf SwipesControl\n     */\n    SwipesControl.prototype.configure = function(config) {\n        if (typeof config === 'object') {\n            if (config.pointersForSwipe !== undefined) {\n                this._hammertime.get('swipe').set({pointers: config.pointersForSwipe});\n            }\n        }\n    };\n    /**\n     *\n     * @returns {boolean}\n     * @memberOf SwipesControl\n     */\n    SwipesControl.prototype.isEnable = function() {\n        return this._isEnable;\n    };\n    /**\n     *\n     * @memberOf SwipesControl\n     */\n    SwipesControl.prototype.enable = function() {\n        if (this._isEnable) return;\n\n        function swipeHandler(e) {\n            self._actionFn(e.direction, [Hammer.DIRECTION_RIGHT, Hammer.DIRECTION_DOWN, Hammer.DIRECTION_LEFT, Hammer.DIRECTION_UP], function(val, defVal) {\n                return val === defVal;\n            });\n            e.preventDefault();\n        }\n\n        var self = this;\n        this._hammertime.on('swipe', swipeHandler);\n        this._swipeHandler = swipeHandler;\n\n        this._isEnable = true;\n    };\n    /**\n     *\n     * @memberOf SwipesControl\n     */\n    SwipesControl.prototype.disable = function() {\n        if (!this._isEnable) return;\n\n        this._hammertime.off('swipe', this._swipeHandler);\n        this._swipeHandler = null;\n\n        this._isEnable = false;\n    };\n    /**\n     *\n     * @memberOf SwipesControl\n     */\n    SwipesControl.prototype.destroy = function() {\n        this.disable();\n    };\n\n    return SwipesControl;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/swipesControl.js\n// module id = 15\n// module chunks = 0","/*! Hammer.JS - v2.0.8 - 2016-04-23\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.8';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./vendor/hammer.js\n// module id = 16\n// module chunks = 0","if (typeof jQuery !== 'undefined') {\n\tinit();\n} else {\n    function getXHR() {\n        var xmlHttp;\n        try {\n            xmlHttp = new ActiveXObject(\"Msxml2.XMLHTTP\");\n        } catch (e) {\n            try {\n                xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n            } catch (E) {\n                xmlHttp = false;\n            }\n        }\n\n        if (!xmlHttp && typeof XMLHttpRequest != 'undefined') {\n            xmlHttp = new XMLHttpRequest();\n        }\n\n        return xmlHttp;\n    }\n    var xhr = getXHR();\n    xhr.open('GET', 'https://code.jquery.com/jquery-3.1.1.min.js', true);\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState == 4) {\n            if (xhr.status != 200) {\n                console.error( 'jQuery loading error: status ' + xhr.status + ': ' + xhr.statusText );\n            } else {\n                eval( xhr.responseText );\n                eval( xhr.responseText ); // todo если выполнить только один раз, почему-то не работает\n\t\t\t\tinit();\n            }\n        }\n    };\n    xhr.send(null);\n}\n\nfunction init() {\n\t/*\n\t * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/\n\t *\n\t * Uses the built in easing capabilities added In jQuery 1.1\n\t * to offer multiple easing options\n\t *\n\t * TERMS OF USE - jQuery Easing\n\t *\n\t * Open source under the BSD License.\n\t *\n\t * Copyright © 2008 George McGinley Smith\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without modification,\n\t * are permitted provided that the following conditions are met:\n\t *\n\t * Redistributions of source code must retain the above copyright notice, this list of\n\t * conditions and the following disclaimer.\n\t * Redistributions in binary form must reproduce the above copyright notice, this list\n\t * of conditions and the following disclaimer in the documentation and/or other materials\n\t * provided with the distribution.\n\t *\n\t * Neither the name of the author nor the names of contributors may be used to endorse\n\t * or promote products derived from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n\t * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n\t * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n\t *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n\t *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n\t * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n\t *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\t * OF THE POSSIBILITY OF SUCH DAMAGE.\n\t *\n\t */\n    // t: current time, b: begInnIng value, c: change In value, d: duration\n    jQuery.easing['jswing'] = jQuery.easing['swing'];\n\n\t//http://easings.net/\n\tjQuery && jQuery.extend( jQuery.easing,\n\t{\n\t\tdef: 'easeOutQuad',\n\t\tswing: function (x, t, b, c, d) {\n\t\t\t//alert(jQuery.easing.default);\n\t\t\treturn jQuery.easing[jQuery.easing.def](x, t, b, c, d);\n\t\t},\n\t\teaseInQuad: function (x, t, b, c, d) {\n\t\t\treturn c*(t/=d)*t + b;\n\t\t},\n\t\teaseOutQuad: function (x, t, b, c, d) {\n\t\t\treturn -c *(t/=d)*(t-2) + b;\n\t\t},\n\t\teaseInOutQuad: function (x, t, b, c, d) {\n\t\t\tif ((t/=d/2) < 1) return c/2*t*t + b;\n\t\t\treturn -c/2 * ((--t)*(t-2) - 1) + b;\n\t\t},\n\t\teaseInCubic: function (x, t, b, c, d) {\n\t\t\treturn c*(t/=d)*t*t + b;\n\t\t},\n\t\teaseOutCubic: function (x, t, b, c, d) {\n\t\t\treturn c*((t=t/d-1)*t*t + 1) + b;\n\t\t},\n\t\teaseInOutCubic: function (x, t, b, c, d) {\n\t\t\tif ((t/=d/2) < 1) return c/2*t*t*t + b;\n\t\t\treturn c/2*((t-=2)*t*t + 2) + b;\n\t\t},\n\t\teaseInQuart: function (x, t, b, c, d) {\n\t\t\treturn c*(t/=d)*t*t*t + b;\n\t\t},\n\t\teaseOutQuart: function (x, t, b, c, d) {\n\t\t\treturn -c * ((t=t/d-1)*t*t*t - 1) + b;\n\t\t},\n\t\teaseInOutQuart: function (x, t, b, c, d) {\n\t\t\tif ((t/=d/2) < 1) return c/2*t*t*t*t + b;\n\t\t\treturn -c/2 * ((t-=2)*t*t*t - 2) + b;\n\t\t},\n\t\teaseInQuint: function (x, t, b, c, d) {\n\t\t\treturn c*(t/=d)*t*t*t*t + b;\n\t\t},\n\t\teaseOutQuint: function (x, t, b, c, d) {\n\t\t\treturn c*((t=t/d-1)*t*t*t*t + 1) + b;\n\t\t},\n\t\teaseInOutQuint: function (x, t, b, c, d) {\n\t\t\tif ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;\n\t\t\treturn c/2*((t-=2)*t*t*t*t + 2) + b;\n\t\t},\n\t\teaseInSine: function (x, t, b, c, d) {\n\t\t\treturn -c * Math.cos(t/d * (Math.PI/2)) + c + b;\n\t\t},\n\t\teaseOutSine: function (x, t, b, c, d) {\n\t\t\treturn c * Math.sin(t/d * (Math.PI/2)) + b;\n\t\t},\n\t\teaseInOutSine: function (x, t, b, c, d) {\n\t\t\treturn -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;\n\t\t},\n\t\teaseInExpo: function (x, t, b, c, d) {\n\t\t\treturn (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\n\t\t},\n\t\teaseOutExpo: function (x, t, b, c, d) {\n\t\t\treturn (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n\t\t},\n\t\teaseInOutExpo: function (x, t, b, c, d) {\n\t\t\tif (t==0) return b;\n\t\t\tif (t==d) return b+c;\n\t\t\tif ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;\n\t\t\treturn c/2 * (-Math.pow(2, -10 * --t) + 2) + b;\n\t\t},\n\t\teaseInCirc: function (x, t, b, c, d) {\n\t\t\treturn -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;\n\t\t},\n\t\teaseOutCirc: function (x, t, b, c, d) {\n\t\t\treturn c * Math.sqrt(1 - (t=t/d-1)*t) + b;\n\t\t},\n\t\teaseInOutCirc: function (x, t, b, c, d) {\n\t\t\tif ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;\n\t\t\treturn c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;\n\t\t},\n\t\teaseInElastic: function (x, t, b, c, d) {\n\t\t\tvar s=1.70158;var p=0;var a=c;\n\t\t\tif (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;\n\t\t\tif (a < Math.abs(c)) { a=c; var s=p/4; }\n\t\t\telse var s = p/(2*Math.PI) * Math.asin (c/a);\n\t\t\treturn -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;\n\t\t},\n\t\teaseOutElastic: function (x, t, b, c, d) {\n\t\t\tvar s=1.70158;var p=0;var a=c;\n\t\t\tif (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;\n\t\t\tif (a < Math.abs(c)) { a=c; var s=p/4; }\n\t\t\telse var s = p/(2*Math.PI) * Math.asin (c/a);\n\t\t\treturn a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;\n\t\t},\n\t\teaseInOutElastic: function (x, t, b, c, d) {\n\t\t\tvar s=1.70158;var p=0;var a=c;\n\t\t\tif (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);\n\t\t\tif (a < Math.abs(c)) { a=c; var s=p/4; }\n\t\t\telse var s = p/(2*Math.PI) * Math.asin (c/a);\n\t\t\tif (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;\n\t\t\treturn a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;\n\t\t},\n\t\teaseInBack: function (x, t, b, c, d, s) {\n\t\t\tif (s == undefined) s = 1.70158;\n\t\t\treturn c*(t/=d)*t*((s+1)*t - s) + b;\n\t\t},\n\t\teaseOutBack: function (x, t, b, c, d, s) {\n\t\t\tif (s == undefined) s = 1.70158;\n\t\t\treturn c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;\n\t\t},\n\t\teaseInOutBack: function (x, t, b, c, d, s) {\n\t\t\tif (s == undefined) s = 1.70158;\n\t\t\tif ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;\n\t\t\treturn c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;\n\t\t},\n\t\teaseInBounce: function (x, t, b, c, d) {\n\t\t\treturn c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;\n\t\t},\n\t\teaseOutBounce: function (x, t, b, c, d) {\n\t\t\tif ((t/=d) < (1/2.75)) {\n\t\t\t\treturn c*(7.5625*t*t) + b;\n\t\t\t} else if (t < (2/2.75)) {\n\t\t\t\treturn c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;\n\t\t\t} else if (t < (2.5/2.75)) {\n\t\t\t\treturn c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;\n\t\t\t} else {\n\t\t\t\treturn c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;\n\t\t\t}\n\t\t},\n\t\teaseInOutBounce: function (x, t, b, c, d) {\n\t\t\tif (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;\n\t\t\treturn jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;\n\t\t}\n\t});\n\n\t/*\n\t *\n\t * TERMS OF USE - EASING EQUATIONS\n\t *\n\t * Open source under the BSD License.\n\t *\n\t * Copyright © 2001 Robert Penner\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without modification,\n\t * are permitted provided that the following conditions are met:\n\t *\n\t * Redistributions of source code must retain the above copyright notice, this list of\n\t * conditions and the following disclaimer.\n\t * Redistributions in binary form must reproduce the above copyright notice, this list\n\t * of conditions and the following disclaimer in the documentation and/or other materials\n\t * provided with the distribution.\n\t *\n\t * Neither the name of the author nor the names of contributors may be used to endorse\n\t * or promote products derived from this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\n\t * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n\t * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n\t *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n\t *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n\t * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n\t *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n\t * OF THE POSSIBILITY OF SUCH DAMAGE.\n\t *\n\t */\n\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./vendor/jquery.easing.js\n// module id = 17\n// module chunks = 0","/**\n * Основной модуль, предоставляющий элементы для настройки и управления панелями<br>\n * Объявляется глобально и доступен через переменную <b>rb</b>\n * @module MainModule\n */\ndefine(['screenModel', 'rbManager', 'IPlugin', 'IControl', '../css/rb.scss'], function(ScreenModel, RbManager, IPlugin, IControl) {\n    \"use strict\";\n\n    return /** @alias module:MainModule */ Object.create(null, {\n        /**\n         * Класс модели отображаемого внутри панели контента, модели связываются в граф зависимостей,\n         * по которому осуществляется перемещение в панели.\n         * @type {ScreenModel}\n         */\n        Screen: {\n            value: ScreenModel\n        },\n        /**\n         * Функция, инициализирующая расположенные в данный момент на странице панели.\n         * @type {function}\n         * @see {@link module:RbManager.init}\n         */\n        start: {\n            value: RbManager.init\n        },\n        /**\n         * Функция, удаляющая панель со страницы.\n         * @type {function}\n         * @see {@link module:RbManager.remove}\n         */\n        remove: {\n            value: RbManager.remove\n        },\n        /**\n         * Набор панелей, действующих в данный момент на странице.\n         * @type {Moving[]}\n         */\n        Instances: {\n            value: {}\n        },\n        /**\n         * Модуль, позволяющий управлять панелями на странице пакетированно, то есть запускать действия для всех панеляй сразу.\n         * @type {module:Batch}\n         */\n        Batch: {\n            value: RbManager.Batch\n        },\n        /**\n         * Интерфейс плагина панели, который можно добавить в панель для расширения ее фунционала.\n         * Добавляемые плагины должны быть именно такого типа.\n         * @type {IPlugin}\n         * @see {@link Moving#addPlugin}\n         * @see {@link Moving#removePlugin}\n         */\n        IPlugin: {\n            value: IPlugin\n        },\n        /**\n         * Интерфейс управления панелью. Позволяет переключаться в соседние ячейки панели.\n         * Добавляемые плагины управления панелью должны быть именно такого типа.\n         * @type {IControl}\n         * @see {@link ControlManager#add}\n         * @see {@link ControlManager#remove}\n         */\n        IControl: {\n            value: IControl\n        }\n    });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/main.js\n// module id = 18\n// module chunks = 0"],"sourceRoot":""}